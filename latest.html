<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Roulette Predictor</title>
    <style>
        /* [Previous CSS remains exactly the same] */
    </style>
</head>
<body>
    <!-- [Previous HTML structure remains the same] -->

    <script>
        // Enhanced wheel layout with physical relationships
        const wheelLayout = [
            {number: 0, neighbors: [32,15,26,3], section: 1},
            {number: 32, neighbors: [0,15,19,26], section: 1, color: 'red'},
            {number: 15, neighbors: [0,32,19,4], section: 1, color: 'black'},
            // [Full wheel layout data...]
        ];

        // New prediction engine
        class PredictionEngine {
            constructor() {
                this.heatMap = this.createHeatMap();
                this.lastNumbers = [];
                this.strategyWeights = {
                    physics: 0.4,    // Wheel physics tendencies
                    trends: 0.3,     // Recent number trends
                    statistics: 0.3   // Historical patterns
                };
            }

            createHeatMap() {
                const map = {};
                wheelLayout.forEach(item => {
                    map[item.number] = {
                        hits: 0,
                        recent: 0,
                        neighbors: item.neighbors
                    };
                });
                return map;
            }

            updateHeatMap(number) {
                this.heatMap[number].hits++;
                this.heatMap[number].recent++;
                
                // Decay recent hits over time
                Object.keys(this.heatMap).forEach(num => {
                    this.heatMap[num].recent *= 0.9;
                });

                this.lastNumbers.unshift(number);
                if(this.lastNumbers.length > 10) this.lastNumbers.pop();
            }

            getPredictions() {
                // 1. Physics-based prediction (wheel mechanics)
                const physicsPrediction = this.getPhysicsPrediction();
                
                // 2. Trend analysis (recent patterns)
                const trendPrediction = this.getTrendPrediction();
                
                // 3. Statistical prediction (hot numbers)
                const statsPrediction = this.getStatsPrediction();

                // Combine predictions with weighted strategy
                const combined = {};
                
                [physicsPrediction, trendPrediction, statsPrediction].forEach((pred, i) => {
                    const weight = Object.values(this.strategyWeights)[i];
                    pred.forEach(num => {
                        combined[num] = (combined[num] || 0) + weight;
                    });
                });

                // Get top 5 predicted numbers
                return Object.entries(combined)
                    .sort((a,b) => b[1] - a[1])
                    .slice(0,5)
                    .map(item => Number(item[0]));
            }

            getPhysicsPrediction() {
                if(this.lastNumbers.length < 2) return [];
                
                const lastNum = this.lastNumbers[0];
                const secondLast = this.lastNumbers[1];
                const wheelItem = wheelLayout.find(item => item.number === lastNum);
                
                // Predict numbers that frequently follow the last number
                const followUps = wheelItem.neighbors
                    .concat(wheelItem.neighbors.flatMap(n => 
                        wheelLayout.find(i => i.number === n).neighbors
                    ));
                
                return [...new Set(followUps)];
            }

            getTrendPrediction() {
                if(this.lastNumbers.length < 3) return [];
                
                // Detect repeating patterns
                const patterns = {};
                for(let i=0; i<this.lastNumbers.length-1; i++) {
                    const key = `${this.lastNumbers[i]}-${this.lastNumbers[i+1]}`;
                    patterns[key] = (patterns[key] || 0) + 1;
                }
                
                // Find most frequent recent transitions
                const lastNum = this.lastNumbers[0];
                const likelyNext = Object.entries(patterns)
                    .filter(([key]) => key.startsWith(lastNum+'-'))
                    .sort((a,b) => b[1] - a[1])
                    .map(([key]) => Number(key.split('-')[1]));
                
                return likelyNext.slice(0,3);
            }

            getStatsPrediction() {
                // Return hottest numbers (recent + historical)
                return Object.entries(this.heatMap)
                    .sort((a,b) => (b[1].recent*3 + b[1].hits) - (a[1].recent*3 + a[1].hits))
                    .slice(0,5)
                    .map(([num]) => Number(num));
            }

            adjustStrategy(result) {
                // Dynamically adjust strategy weights based on performance
                if(result) {
                    // Reward successful strategies
                    this.strategyWeights.physics *= 1.1;
                    this.strategyWeights.trends *= 1.05;
                } else {
                    // Penalize failing strategies
                    this.strategyWeights.physics *= 0.9;
                    this.strategyWeights.trends *= 0.95;
                    
                    // After 3 losses, increase statistical weighting
                    if(this.consecutiveLosses >= 3) {
                        this.strategyWeights.statistics = Math.min(
                            this.strategyWeights.statistics * 1.2, 0.5
                        );
                    }
                }
                
                // Normalize weights
                const total = Object.values(this.strategyWeights).reduce((a,b) => a+b);
                Object.keys(this.strategyWeights).forEach(key => {
                    this.strategyWeights[key] /= total;
                });
            }
        }

        // Initialize application with new engine
        const engine = new PredictionEngine();
        let state = {
            spins: [],
            predictions: [],
            currentStreak: 0,
            maxStreak: 0,
            strategyPerformance: {
                physics: { used: 0, correct: 0 },
                trends: { used: 0, correct: 0 },
                statistics: { used: 0, correct: 0 }
            }
        };

        // [Rest of the application code remains similar but uses the new engine]
        
        function makePrediction() {
            const lastSpin = state.spins[state.spins.length - 1];
            engine.updateHeatMap(lastSpin.number);
            
            const predictedNumbers = engine.getPredictions();
            const actualNumber = /* get next number */;
            
            const isCorrect = predictedNumbers.includes(actualNumber);
            engine.adjustStrategy(isCorrect);
            
            // Update streaks and statistics
            if(isCorrect) {
                state.currentStreak = 0;
            } else {
                state.currentStreak++;
                if(state.currentStreak > state.maxStreak) {
                    state.maxStreak = state.currentStreak;
                    
                    // Emergency broadening after 5 losses
                    if(state.currentStreak >= 5) {
                        predictedNumbers.push(...engine.getStatsPrediction().slice(0,3));
                    }
                }
            }
            
            // [Rest of prediction handling...]
        }
    </script>
</body>
</html>
