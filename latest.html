<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roulette Prediction Engine</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .wheel-viz {
            width: 400px;
            height: 400px;
            margin: 0 auto;
            position: relative;
        }
        .number {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            transform-origin: center;
        }
        .red { background-color: #e74c3c; }
        .black { background-color: #2c3e50; }
        .green { background-color: #27ae60; }
        .predicted {
            box-shadow: 0 0 0 3px #f39c12;
            z-index: 10;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid #ddd;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        .correct { color: #27ae60; font-weight: bold; }
        .incorrect { color: #e74c3c; }
        .streak-warning { color: #f39c12; }
        .streak-critical { color: #c0392b; }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #2980b9;
        }
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>Roulette Prediction Engine</h1>
    
    <div class="controls">
        <textarea id="numberInput" placeholder="Paste your sequence of numbers here (one per line or space/comma separated)"></textarea>
    </div>
    
    <div class="controls">
        <button id="analyzeBtn">Analyze & Predict</button>
        <button id="resetBtn">Reset</button>
        <button id="nextBtn">Next Prediction</button>
    </div>
    
    <div class="stats">
        <div class="stat-card">
            <div>Total Spins</div>
            <div class="stat-value" id="totalSpins">0</div>
        </div>
        <div class="stat-card">
            <div>Predictions</div>
            <div class="stat-value" id="totalPredictions">0</div>
        </div>
        <div class="stat-card">
            <div>Accuracy</div>
            <div class="stat-value" id="accuracy">0%</div>
        </div>
        <div class="stat-card">
            <div>Current Streak</div>
            <div class="stat-value" id="currentStreak">0</div>
        </div>
    </div>
    
    <div class="dashboard">
        <div class="panel">
            <h2>Wheel Visualization</h2>
            <div class="wheel-viz" id="wheel"></div>
            <div>
                <h3>Current Prediction</h3>
                <p>Next Spin Direction: <strong id="nextDirection">-</strong></p>
                <p>Predicted Numbers (19): <span id="predictedNumbers">-</span></p>
                <p>Confidence: <span id="confidence">-</span></p>
            </div>
        </div>
        
        <div class="panel">
            <h2>Prediction History</h2>
            <table id="historyTable">
                <thead>
                    <tr>
                        <th>Spin</th>
                        <th>Predicted</th>
                        <th>Actual</th>
                        <th>Result</th>
                        <th>Direction</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <script>
        // European roulette wheel layout (clockwise)
        const EUROPEAN_WHEEL = [
            0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26
        ];
        
        // Red numbers
        const RED_NUMBERS = [32, 19, 21, 25, 34, 27, 36, 30, 23, 5, 16, 1, 14, 9, 18, 7, 12, 3];
        
        // Application state
        let spins = [];
        let predictions = [];
        let currentStreak = 0;
        let maxStreak = 0;
        let currentPosition = 0;
        let numberFrequency = {};
        let directionalPatterns = { CW: {}, CCW: {} };

        // Initialize wheel visualization
        function initWheel() {
            const wheel = document.getElementById('wheel');
            wheel.innerHTML = '';
            const center = 200;
            const radius = 180;
            const angleStep = (2 * Math.PI) / EUROPEAN_WHEEL.length;
            
            EUROPEAN_WHEEL.forEach((num, index) => {
                const angle = index * angleStep;
                const x = center + radius * Math.sin(angle);
                const y = center - radius * Math.cos(angle);
                
                const numElement = document.createElement('div');
                numElement.className = 'number';
                numElement.textContent = num;
                numElement.id = `num-${num}`;
                numElement.style.left = `${x}px`;
                numElement.style.top = `${y}px`;
                
                if (num === 0) {
                    numElement.classList.add('green');
                } else if (RED_NUMBERS.includes(num)) {
                    numElement.classList.add('red');
                } else {
                    numElement.classList.add('black');
                }
                
                wheel.appendChild(numElement);
            });
        }

        // Parse input numbers
        function parseInput(input) {
            return input.trim()
                .split(/[\s,\n]+/)
                .filter(x => x !== '')
                .map(x => parseInt(x))
                .filter(x => !isNaN(x) && x >= 0 && x <= 36);
        }

        // Analyze number frequencies and patterns
        function analyzeData() {
            numberFrequency = {};
            directionalPatterns = { CW: {}, CCW: {} };
            
            // Calculate number frequencies
            spins.forEach(num => {
                numberFrequency[num] = (numberFrequency[num] || 0) + 1;
            });
            
            // Calculate directional patterns (how often numbers follow others in each direction)
            for (let i = 1; i < spins.length; i++) {
                const current = spins[i];
                const prev = spins[i - 1];
                const direction = i % 2 === 1 ? 'CW' : 'CCW'; // Alternating directions
                
                if (!directionalPatterns[direction][prev]) {
                    directionalPatterns[direction][prev] = {};
                }
                
                directionalPatterns[direction][prev][current] = 
                    (directionalPatterns[direction][prev][current] || 0) + 1;
            }
        }

        // Generate prediction for next spin
        function generatePrediction() {
            if (spins.length < 2) return null;
            
            const lastNumber = spins[spins.length - 1];
            const nextDirection = spins.length % 2 === 0 ? 'CW' : 'CCW';
            
            // 1. Base prediction (9 neighbors each side)
            const wheelOrder = nextDirection === 'CW' ? [...EUROPEAN_WHEEL] : [...EUROPEAN_WHEEL].reverse();
            const centerIndex = wheelOrder.indexOf(lastNumber);
            let predictedNumbers = [];
            
            for (let i = -9; i <= 9; i++) {
                const neighborIndex = (centerIndex + i + wheelOrder.length) % wheelOrder.length;
                predictedNumbers.push(wheelOrder[neighborIndex]);
            }
            
            // 2. Boost numbers that frequently follow in this direction
            const directionalBoosts = directionalPatterns[nextDirection][lastNumber] || {};
            const boostedNumbers = Object.entries(directionalBoosts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(x => parseInt(x[0]));
            
            // 3. Include hot numbers (most frequent in recent spins)
            const recentSpins = spins.slice(-30);
            const frequencyMap = {};
            recentSpins.forEach(num => {
                frequencyMap[num] = (frequencyMap[num] || 0) + 1;
            });
            const hotNumbers = Object.entries(frequencyMap)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(x => parseInt(x[0]));
            
            // Combine all approaches (prioritize base prediction)
            const finalPrediction = [...new Set([
                ...predictedNumbers.slice(0, 15), // First 15 from base prediction
                ...boostedNumbers,
                ...hotNumbers
            ])].slice(0, 19);
            
            return {
                direction: nextDirection,
                numbers: finalPrediction,
                confidence: calculateConfidence(finalPrediction, lastNumber, nextDirection)
            };
        }

        // Calculate prediction confidence (0-100%)
        function calculateConfidence(prediction, lastNumber, direction) {
            let confidence = 50; // Base confidence
            
            // Boost if predicted numbers include frequently following numbers
            const commonFollowers = directionalPatterns[direction][lastNumber] || {};
            const matchingFollowers = prediction.filter(num => commonFollowers[num]);
            if (matchingFollowers.length > 0) {
                confidence += 15 * matchingFollowers.length;
            }
            
            // Boost if including hot numbers
            const recentSpins = spins.slice(-30);
            const hotNumbers = [...new Set(recentSpins)]
                .sort((a, b) => 
                    recentSpins.filter(x => x === b).length - 
                    recentSpins.filter(x => x === a).length
                )
                .slice(0, 3);
                
            const matchingHot = prediction.filter(num => hotNumbers.includes(num));
            if (matchingHot.length > 0) {
                confidence += 10 * matchingHot.length;
            }
            
            return Math.min(95, Math.max(5, confidence)); // Keep between 5-95%
        }

        // Process next spin and update predictions
        function processNextSpin() {
            if (currentPosition >= spins.length) return;
            
            const actualNumber = spins[currentPosition];
            let prediction = null;
            
            // Only predict if we have at least 2 spins of history
            if (currentPosition >= 2) {
                prediction = generatePrediction();
                
                const isCorrect = prediction.numbers.includes(actualNumber);
                if (isCorrect) {
                    currentStreak = 0;
                } else {
                    currentStreak++;
                    maxStreak = Math.max(maxStreak, currentStreak);
                }
                
                predictions.push({
                    spinNumber: currentPosition + 1,
                    predictedNumbers: prediction.numbers,
                    actual: actualNumber,
                    correct: isCorrect,
                    direction: prediction.direction,
                    confidence: prediction.confidence
                });
                
                updatePredictionDisplay(prediction, isCorrect);
            }
            
            currentPosition++;
            updateStats();
            updateHistoryTable();
            
            if (currentPosition < spins.length) {
                document.getElementById('nextBtn').textContent = `Next Spin (${spins[currentPosition]})`;
            } else {
                document.getElementById('nextBtn').textContent = 'No more spins';
                document.getElementById('nextBtn').disabled = true;
            }
        }

        // Update prediction display
        function updatePredictionDisplay(prediction, isCorrect) {
            if (!prediction) return;
            
            document.getElementById('nextDirection').textContent = prediction.direction;
            document.getElementById('predictedNumbers').textContent = prediction.numbers.join(', ');
            document.getElementById('confidence').textContent = `${prediction.confidence}%`;
            
            // Highlight predicted numbers on wheel
            document.querySelectorAll('.number').forEach(el => {
                el.classList.remove('predicted');
            });
            
            prediction.numbers.forEach(num => {
                const el = document.getElementById(`num-${num}`);
                if (el) el.classList.add('predicted');
            });
        }

        // Update statistics
        function updateStats() {
            document.getElementById('totalSpins').textContent = spins.length;
            document.getElementById('totalPredictions').textContent = predictions.length;
            
            const correct = predictions.filter(p => p.correct).length;
            const accuracy = predictions.length > 0 
                ? Math.round((correct / predictions.length) * 100)
                : 0;
            
            document.getElementById('accuracy').textContent = `${accuracy}%`;
            
            const streakElement = document.getElementById('currentStreak');
            streakElement.textContent = currentStreak;
            streakElement.className = '';
            
            if (currentStreak >= 4) streakElement.classList.add('streak-warning');
            if (currentStreak >= 6) streakElement.classList.add('streak-critical');
        }

        // Update history table
        function updateHistoryTable() {
            const tbody = document.querySelector('#historyTable tbody');
            tbody.innerHTML = '';
            
            predictions.slice().reverse().slice(0, 20).forEach(pred => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${pred.spinNumber}</td>
                    <td>${pred.predictedNumbers.join(', ')}</td>
                    <td>${pred.actual}</td>
                    <td class="${pred.correct ? 'correct' : 'incorrect'}">
                        ${pred.correct ? '✓' : '✗'} (${pred.confidence}%)
                    </td>
                    <td>${pred.direction}</td>
                `;
                tbody.appendChild(row);
            });
        }

        // Reset everything
        function reset() {
            spins = [];
            predictions = [];
            currentStreak = 0;
            maxStreak = 0;
            currentPosition = 0;
            numberFrequency = {};
            directionalPatterns = { CW: {}, CCW: {} };
            
            document.getElementById('totalSpins').textContent = '0';
            document.getElementById('totalPredictions').textContent = '0';
            document.getElementById('accuracy').textContent = '0%';
            document.getElementById('currentStreak').textContent = '0';
            document.getElementById('nextDirection').textContent = '-';
            document.getElementById('predictedNumbers').textContent = '-';
            document.getElementById('confidence').textContent = '-';
            document.querySelector('#historyTable tbody').innerHTML = '';
            document.getElementById('nextBtn').textContent = 'Next Prediction';
            document.getElementById('nextBtn').disabled = false;
            
            document.querySelectorAll('.number').forEach(el => {
                el.classList.remove('predicted');
            });
        }

        // Event listeners
        document.getElementById('analyzeBtn').addEventListener('click', () => {
            const input = document.getElementById('numberInput').value;
            spins = parseInput(input);
            
            if (spins.length < 2) {
                alert('Please enter at least 2 numbers to analyze');
                return;
            }
            
            analyzeData();
            currentPosition = 0;
            predictions = [];
            updateStats();
            
            // Process first prediction
            processNextSpin();
            processNextSpin(); // Need at least 2 spins to start predicting
        });
        
        document.getElementById('resetBtn').addEventListener('click', reset);
        
        document.getElementById('nextBtn').addEventListener('click', processNextSpin);

        // Initialize
        window.addEventListener('load', initWheel);
    </script>
</body>
</html>
