<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Adaptive Roulette CS Predictor</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #0b1020;
      color: #f5f5f5;
    }
    h1, h2, h3 {
      margin-top: 0;
      font-weight: 700;
    }
    h1 { font-size: 1.8rem; }
    h2 { font-size: 1.3rem; margin-top: 1.5rem; }
    h3 { font-size: 1.1rem; margin-top: 1rem; }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 3fr);
      gap: 1.5rem;
    }
    @media (max-width: 900px) {
      .container { grid-template-columns: 1fr; }
    }

    .card {
      background: #151a2c;
      border-radius: 14px;
      padding: 1.1rem 1.25rem;
      box-shadow: 0 14px 40px rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.04);
    }

    label { display: block; margin-bottom: 0.35rem; font-size: 0.9rem; opacity: 0.9; }
    input[type="number"], textarea {
      width: 100%;
      padding: 0.6rem 0.7rem;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: #0b1020;
      color: #f5f5f5;
      font-size: 0.95rem;
      outline: none;
    }
    input[type="number"]:focus, textarea:focus {
      border-color: #58d5ff;
      box-shadow: 0 0 0 1px rgba(88,213,255,0.3);
    }
    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.55rem 0.9rem;
      border-radius: 999px;
      border: 0;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      margin-right: 0.5rem;
      margin-top: 0.4rem;
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.15s ease;
    }
    .btn-primary {
      background: #ff3366;
      color: #fff;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.05),0 10px 25px rgba(255,51,102,0.4);
    }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 14px 30px rgba(255,51,102,0.5); }
    .btn-secondary {
      background: #232b49;
      color: #f5f5f5;
    }
    .btn-secondary:hover { background: #2f385c; }

    .pill {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .pill-good { background: rgba(0,200,140,0.15); color: #4cf3b6; }
    .pill-neutral { background: rgba(130,150,255,0.15); color: #b3bfff; }

    .section {
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(255,255,255,0.06);
    }

    .list-inline {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem 0.4rem;
      margin: 0.25rem 0;
      padding: 0;
      list-style: none;
      font-size: 0.9rem;
    }
    .list-inline li {
      padding: 0.17rem 0.5rem;
      border-radius: 999px;
      background: rgba(255,255,255,0.05);
    }

    .mono { font-family: "SF Mono", Menlo, Consolas, monospace; font-size: 0.85rem; }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.6rem;
      margin-top: 0.4rem;
    }
    @media (max-width: 600px) {
      .stat-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    .stat {
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      padding: 0.5rem 0.6rem;
      font-size: 0.8rem;
    }
    .stat span { display: block; }
    .stat-label { opacity: 0.7; margin-bottom: 0.1rem; }
    .stat-value { font-weight: 700; font-size: 0.95rem; }

    .small { font-size: 0.8rem; opacity: 0.8; }

    .params-badge {
      font-family: "SF Mono", Menlo, Consolas, monospace;
      background: rgba(255,255,255,0.05);
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 999px;
      font-size: 0.75rem;
      margin-top: 0.5rem;
      margin-bottom: 0.75rem;
    }
  </style>
</head>
<body>

  <h1>Adaptive Roulette CS Predictor</h1>
  <p class="small">
    Spins are assumed to <strong>alternate direction</strong> (CW, CCW, CW, CCW, ...).<br>
    For each spin, the model:
    <br>• Builds wheel distances in that spin's direction,
    <br>• Learns separate <strong>a, b, extraShift</strong> parameters for CW and CCW,
    <br>• Uses exponential forgetting so recent spins matter more,
    <br>• Predicts the next distance via a Callan–Symanzik style formula,
    <br>• Covers the predicted number plus 8 neighbours each side (17 numbers),
    <br>• Uses a Martingale on stake per number (doubling on each loss, reset after 11 consecutive losses).
  </p>

  <div class="params-badge" id="paramBadge">
    CW: a=0.94, b=0.36, shift=4, samples=0  |  CCW: a=0.94, b=0.36, shift=4, samples=0
  </div>

  <div class="container">
    <!-- LIVE INPUT / OUTPUT -->
    <div class="card">
      <h2>Live Mode</h2>

      <label for="baseUnitInput">Base stake per number</label>
      <input type="number" id="baseUnitInput" min="0.01" step="0.01" value="1" />

      <div class="section">
        <label for="spinInput">Enter latest spin (0–36), then click "Add Spin"</label>
        <input type="number" id="spinInput" min="0" max="36" placeholder="e.g. 23" />
        <div>
          <button class="btn btn-primary" id="addSpinBtn">Add Spin</button>
          <button class="btn btn-secondary" id="resetSpinsBtn">Reset History</button>
        </div>
      </div>

      <div class="section">
        <h3>Current History</h3>
        <div class="small" id="historyInfo">No spins yet.</div>
        <ul class="list-inline mono" id="historyList"></ul>
      </div>

      <div class="section">
        <h3>Next Spin Recommendation</h3>
        <div id="recommendation">
          <span class="pill pill-neutral">No Data</span>
          <p class="small">Enter some spins or bulk-load history to get started.</p>
        </div>
      </div>

      <div class="section">
        <h3>Live Stats (this session)</h3>
        <div class="stat-grid">
          <div class="stat">
            <span class="stat-label">Total Bets</span>
            <span class="stat-value" id="liveTotalBets">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Wins</span>
            <span class="stat-value" id="liveWins">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Losses</span>
            <span class="stat-value" id="liveLosses">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Hit Rate</span>
            <span class="stat-value" id="liveHitRate">–</span>
          </div>
          <div class="stat">
            <span class="stat-label">Current Losing Streak</span>
            <span class="stat-value" id="liveCurrentStreak">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Worst Losing Streak</span>
            <span class="stat-value" id="liveWorstStreak">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Profit / Loss</span>
            <span class="stat-value" id="liveProfit">+0.00</span>
          </div>
          <div class="stat">
            <span class="stat-label">Current Stake / Number</span>
            <span class="stat-value" id="liveStakePerNumber">–</span>
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Bulk Load Spins (updates the model as if live)</h3>
        <p class="small">
          Paste spins (0–36), separated by spaces, commas, or new lines.
          This will replace your current live history and re-score all bets
          with the current adaptive model.
        </p>
        <textarea id="bulkLiveInput" placeholder="Example:
26 34 16 4 10 10 27 29 17 8 35 7 23 ..."></textarea>
        <div>
          <button class="btn btn-primary" id="loadBulkLiveBtn">Load Into Live Model</button>
        </div>
      </div>
    </div>

    <!-- SIMULATOR -->
    <div class="card">
      <h2>Simulator (using current parameters)</h2>
      <p class="small">
        Paste a list of spins. The simulator will run the CS model + Martingale
        using the <strong>current</strong> CW/CCW parameters.
        It does <em>not</em> adapt while simulating (so it won't overwrite your live model).
      </p>

      <label for="simInput">Spin sequence</label>
      <textarea id="simInput" placeholder="Example:
26 34 16 4 10 10 27 29 17 8 35 7 23 36 36 25 10 21 8 19 ..."></textarea>

      <div>
        <button class="btn btn-primary" id="runSimBtn">Run Simulation</button>
        <button class="btn btn-secondary" id="clearSimBtn">Clear</button>
      </div>

      <div class="section" id="simResults" style="display:none;">
        <h3>Simulation Results</h3>
        <div class="stat-grid">
          <div class="stat">
            <span class="stat-label">Spins</span>
            <span class="stat-value" id="simSpins">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Total Bets</span>
            <span class="stat-value" id="simTotalBets">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Wins</span>
            <span class="stat-value" id="simWins">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Losses</span>
            <span class="stat-value" id="simLosses">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Hit Rate</span>
            <span class="stat-value" id="simHitRate">–</span>
          </div>
          <div class="stat">
            <span class="stat-label">Worst Losing Streak</span>
            <span class="stat-value" id="simWorstStreak">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Profit / Loss</span>
            <span class="stat-value" id="simProfit">+0.00</span>
          </div>
        </div>
        <p class="small" id="simNotes"></p>
      </div>
    </div>
  </div>

  <script>
    // ---------- WHEEL & CONSTANTS ----------

    const WHEEL_ORDER = [
      0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6,
      27, 13, 36, 11, 30, 8, 23, 10, 5, 24,
      16, 33, 1, 20, 14, 31, 9, 22, 18, 29,
      7, 28, 12, 35, 3, 26
    ];

    const INDEX_OF = {};
    WHEEL_ORDER.forEach((n, i) => { INDEX_OF[n] = i; });

    const HALF_SECTOR = 8;              // neighbours each side (17 numbers total)
    const LOSS_RESET_MARTINGALE = 11;   // reset stake after 11 consecutive losing bets

    // ---------- ADAPTIVE PARAMETERS (PER DIRECTION) ----------

    const INITIAL_PARAMS = {
      CW:  { extraShift: 4, aFixed: 0.94, bFixed: 0.36 },
      CCW: { extraShift: 4, aFixed: 0.94, bFixed: 0.36 }
    };

    let AUTO_PARAMS = JSON.parse(JSON.stringify(INITIAL_PARAMS));

    // Running state per direction for fitting:
    // (S4 - S3) ≈ a * beta + b * gamma, and residual -> extraShift
    const adaptiveState = {
      CW:  { n: 0, s11: 0, s12: 0, s22: 0, s1y: 0, s2y: 0, errMean: 0 },
      CCW: { n: 0, s11: 0, s12: 0, s22: 0, s1y: 0, s2y: 0, errMean: 0 }
    };

    // Forgetting factor (0.98 ≈ stronger memory, 0.90 ≈ fast adaptation)
    const LS_DECAY = 0.98;

    // ---------- UTILITIES ----------

    function neighboursForCentre(centreNum) {
      const idx = INDEX_OF[centreNum];
      if (idx === undefined) return [];
      const nums = [];
      for (let offset = -HALF_SECTOR; offset <= HALF_SECTOR; offset++) {
        const j = (idx + offset + 37) % 37;
        nums.push(WHEEL_ORDER[j]);
      }
      return nums;
    }

    // simple alternating pattern: 0: CW, 1: CCW, 2: CW, ...
    function directionForIndex(i) {
      return i % 2 === 0 ? "CW" : "CCW";
    }

    // Build directional distances from full spin history.
    function buildDirectionalDistances(spins) {
      const distances = [];
      if (spins.length < 2) return distances;

      for (let i = 1; i < spins.length; i++) {
        const prev = spins[i - 1];
        const curr = spins[i];
        const idxPrev = INDEX_OF[prev];
        const idxCurr = INDEX_OF[curr];
        if (idxPrev === undefined || idxCurr === undefined) continue;

        const dir = directionForIndex(i); // direction of spin i
        let dist;
        if (dir === "CW") {
          dist = (idxCurr - idxPrev + 37) % 37;
        } else {
          dist = (idxPrev - idxCurr + 37) % 37;
        }
        distances.push({ dir, dist });
      }
      return distances;
    }

    function parseSpinText(text) {
      const tokens = text.split(/[\s,;]+/).filter(Boolean);
      const arr = [];
      for (const t of tokens) {
        const v = parseInt(t, 10);
        if (!isNaN(v) && v >= 0 && v <= 36) {
          arr.push(v);
        }
      }
      return arr;
    }

    function getBaseUnit() {
      const input = document.getElementById("baseUnitInput");
      const v = parseFloat(input.value);
      if (!isNaN(v) && v > 0) return v;
      return 1;
    }

    function formatMoney(x) {
      const sign = x >= 0 ? "+" : "";
      return sign + x.toFixed(2);
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function updateParamBadge() {
      const badge = document.getElementById("paramBadge");
      const cw = AUTO_PARAMS.CW;
      const ccw = AUTO_PARAMS.CCW;
      badge.textContent =
        `CW: a=${cw.aFixed.toFixed(2)}, b=${cw.bFixed.toFixed(2)}, shift=${cw.extraShift}, samples=${adaptiveState.CW.n}  |  ` +
        `CCW: a=${ccw.aFixed.toFixed(2)}, b=${ccw.bFixed.toFixed(2)}, shift=${ccw.extraShift}, samples=${adaptiveState.CCW.n}`;
    }

    // ---------- ADAPTIVE UPDATE (a, b, extraShift PER DIRECTION) ----------

    // Call this AFTER adding a new spin to history.
    function maybeUpdateAdaptiveParamsFromSpins(spins) {
      const distances = buildDirectionalDistances(spins);
      if (distances.length < 4) return;

      const lastDir = distances[distances.length - 1].dir;
      const sameDir = distances.filter(d => d.dir === lastDir);
      if (sameDir.length < 4) return;

      const len = sameDir.length;
      const S1 = sameDir[len - 4].dist;
      const S2 = sameDir[len - 3].dist;
      const S3 = sameDir[len - 2].dist;
      const S4 = sameDir[len - 1].dist;

      const beta  = S3 - S2;
      const gamma = (S3 - S2) - (S2 - S1);
      const y  = S4 - S3;   // what actually happened
      const x1 = beta;
      const x2 = gamma;

      if (x1 === 0 && x2 === 0) return;

      const st = adaptiveState[lastDir];
      const p  = AUTO_PARAMS[lastDir];

      // Exponential forgetting on least-squares accumulators
      st.s11 *= LS_DECAY;
      st.s12 *= LS_DECAY;
      st.s22 *= LS_DECAY;
      st.s1y *= LS_DECAY;
      st.s2y *= LS_DECAY;

      st.n += 1;
      st.s11 += x1 * x1;
      st.s12 += x1 * x2;
      st.s22 += x2 * x2;
      st.s1y += x1 * y;
      st.s2y += x2 * y;

      const { s11, s12, s22, s1y, s2y } = st;
      const den = s11 * s22 - s12 * s12;
      if (Math.abs(den) > 1e-6) {
        let aHat = ( s22 * s1y - s12 * s2y ) / den;
        let bHat = ( s11 * s2y - s12 * s1y ) / den;

        const mix = 0.2; // 20% new info
        p.aFixed = clamp((1 - mix) * p.aFixed + mix * aHat, -2, 2);
        p.bFixed = clamp((1 - mix) * p.bFixed + mix * bHat, -2, 2);
      }

      // ---- extraShift adaptation for this direction ----
      const S4_pred_noShift = S3 + p.aFixed * beta + p.bFixed * gamma;

      let rawErr = S4 - S4_pred_noShift; // pockets
      // wrap error into circular range [-18,18]
      rawErr = ((rawErr % 37) + 37) % 37; // 0..36
      if (rawErr > 18) rawErr -= 37;

      const errMix = 0.1;
      st.errMean = st.n === 1
        ? rawErr
        : (1 - errMix) * st.errMean + errMix * rawErr;

      let newShift = Math.round(st.errMean);
      newShift = clamp(newShift, 0, 10);
      p.extraShift = newShift;

      updateParamBadge();
    }

    // ---------- CS MODEL USING AUTO_PARAMS ----------

    function csPrediction(spins, params = AUTO_PARAMS) {
      if (spins.length < 4) {
        return {
          shouldBet: false,
          reason: "Need at least 4 spins for the CS flow model.",
          debug: null
        };
      }

      const lastNum = spins[spins.length - 1];
      const idxLast = INDEX_OF[lastNum];
      if (idxLast === undefined) {
        return { shouldBet: false, reason: "Last number not on wheel", debug: null };
      }

      const distances = buildDirectionalDistances(spins);

      const nextIndex = spins.length;
      const upcomingDir = directionForIndex(nextIndex);
      const paramsForDir = params[upcomingDir];
      if (!paramsForDir) {
        return { shouldBet: false, reason: "No parameters for direction " + upcomingDir, debug: null };
      }

      const dirDistances = distances
        .filter(d => d.dir === upcomingDir)
        .map(d => d.dist);

      if (dirDistances.length < 3) {
        return {
          shouldBet: false,
          reason: `Need at least 3 distances in ${upcomingDir} direction (have ${dirDistances.length})`,
          debug: { upcomingDir, dirDistances }
        };
      }

      const S1 = dirDistances[dirDistances.length - 3];
      const S2 = dirDistances[dirDistances.length - 2];
      const S3 = dirDistances[dirDistances.length - 1];

      const beta  = S3 - S2;
      const gamma = (S3 - S2) - (S2 - S1);

      const a = paramsForDir.aFixed;
      const b = paramsForDir.bFixed;

      let S4 = S3 + a * beta + b * gamma;
      S4 = Math.round(S4);
      S4 = ((S4 % 37) + 37) % 37;

      const extraShift = paramsForDir.extraShift || 0;
      const stepWithBias = (S4 + extraShift) % 37;

      let centreIdx;
      if (upcomingDir === "CW") {
        centreIdx = (idxLast + stepWithBias) % 37;
      } else {
        centreIdx = (idxLast - stepWithBias + 74) % 37;
      }

      const centreNum = WHEEL_ORDER[centreIdx];
      const neighbours = neighboursForCentre(centreNum);

      return {
        shouldBet: true,
        centreNum,
        neighbours,
        dominantStep: stepWithBias,
        reason: `CS flow (${upcomingDir}): a=${a.toFixed(2)}, b=${b.toFixed(2)}, extraShift=${extraShift}.`,
        debug: {
          upcomingDir,
          S1, S2, S3,
          beta, gamma,
          S4,
          extraShift,
          stepWithBias,
          centreIdx,
          centreNum,
          a, b,
          nDir: dirDistances.length
        }
      };
    }

    // ---------- LIVE MODE + MARTINGALE ----------

    const spinsLive = [];
    let liveTotalBets = 0;
    let liveWins = 0;
    let liveLosses = 0;
    let liveCurrentLosingStreak = 0;
    let liveWorstStreak = 0;

    let liveProfit = 0;
    let liveStakePerNumber = null;
    let liveMartingaleLossCount = 0;

    const spinInput = document.getElementById("spinInput");
    const addSpinBtn = document.getElementById("addSpinBtn");
    const resetSpinsBtn = document.getElementById("resetSpinsBtn");
    const historyInfo = document.getElementById("historyInfo");
    const historyList = document.getElementById("historyList");
    const recommendationDiv = document.getElementById("recommendation");

    const liveTotalBetsEl = document.getElementById("liveTotalBets");
    const liveWinsEl = document.getElementById("liveWins");
    const liveLossesEl = document.getElementById("liveLosses");
    const liveHitRateEl = document.getElementById("liveHitRate");
    const liveCurrentStreakEl = document.getElementById("liveCurrentStreak");
    const liveWorstStreakEl = document.getElementById("liveWorstStreak");
    const liveProfitEl = document.getElementById("liveProfit");
    const liveStakePerNumberEl = document.getElementById("liveStakePerNumber");

    let lastPrediction = null;

    function updateHistoryUI() {
      if (spinsLive.length === 0) {
        historyInfo.textContent = "No spins yet.";
        historyList.innerHTML = "";
        return;
      }
      historyInfo.textContent = `Total spins: ${spinsLive.length} (showing last 20)`;
      const last20 = spinsLive.slice(-20);
      historyList.innerHTML = "";
      last20.forEach(n => {
        const li = document.createElement("li");
        li.textContent = n;
        historyList.appendChild(li);
      });
    }

    function updateStatsUI() {
      liveTotalBetsEl.textContent = liveTotalBets;
      liveWinsEl.textContent = liveWins;
      liveLossesEl.textContent = liveLosses;
      liveCurrentStreakEl.textContent = liveCurrentLosingStreak;
      liveWorstStreakEl.textContent = liveWorstStreak;
      if (liveTotalBets === 0) {
        liveHitRateEl.textContent = "–";
      } else {
        const rate = (liveWins / liveTotalBets) * 100;
        liveHitRateEl.textContent = rate.toFixed(1) + "%";
      }
      liveProfitEl.textContent = formatMoney(liveProfit);
      if (liveStakePerNumber == null) {
        liveStakePerNumberEl.textContent = "–";
      } else {
        liveStakePerNumberEl.textContent = liveStakePerNumber.toFixed(2);
      }
    }

    function renderRecommendation(pred) {
      recommendationDiv.innerHTML = "";

      if (!pred) {
        const pill = document.createElement("span");
        pill.className = "pill pill-neutral";
        pill.textContent = "No Data";
        recommendationDiv.appendChild(pill);
        const p = document.createElement("p");
        p.className = "small";
        p.textContent = "Enter more spins to get a prediction.";
        recommendationDiv.appendChild(p);
        return;
      }

      if (!pred.shouldBet) {
        const pill = document.createElement("span");
        pill.className = "pill pill-neutral";
        pill.textContent = "NO BET";
        recommendationDiv.appendChild(pill);
        const p = document.createElement("p");
        p.className = "small";
        p.textContent = pred.reason || "Pattern not strong enough yet.";
        recommendationDiv.appendChild(p);
      } else {
        const pill = document.createElement("span");
        pill.className = "pill pill-good";
        pill.textContent = "BET";
        recommendationDiv.appendChild(pill);

        const p1 = document.createElement("p");
        p1.innerHTML =
          `Centre: <strong>${pred.centreNum}</strong>` +
          ` &mdash; Step: <span class="mono">${pred.dominantStep}</span>`;
        recommendationDiv.appendChild(p1);

        const p2 = document.createElement("p");
        p2.className = "small";
        p2.textContent = "Cover this number and its 8 neighbours each side on the wheel (17 numbers):";
        recommendationDiv.appendChild(p2);

        const ul = document.createElement("ul");
        ul.className = "list-inline mono";
        pred.neighbours.forEach(n => {
          const li = document.createElement("li");
          li.textContent = n;
          ul.appendChild(li);
        });
        recommendationDiv.appendChild(ul);

        if (pred.reason) {
          const p3 = document.createElement("p");
          p3.className = "small";
          p3.textContent = pred.reason;
          recommendationDiv.appendChild(p3);
        }
      }
    }

    function onAddSpin() {
      const v = parseInt(spinInput.value, 10);
      if (isNaN(v) || v < 0 || v > 36) {
        alert("Please enter a valid number between 0 and 36.");
        return;
      }

      const baseUnit = getBaseUnit();

      // 1) Score previous prediction using this result
      if (lastPrediction && lastPrediction.shouldBet) {
        liveTotalBets++;

        const neighbours = lastPrediction.neighbours || [];
        const numbersCovered = neighbours.length;
        const stakePerNumberNow = (liveStakePerNumber == null) ? baseUnit : liveStakePerNumber;
        const totalStake = stakePerNumberNow * numbersCovered;

        const hit = neighbours.includes(v);
        if (hit) {
          const winReturn = stakePerNumberNow * 36;
          const profit = winReturn - totalStake;
          liveProfit += profit;

          liveWins++;
          liveCurrentLosingStreak = 0;
          liveMartingaleLossCount = 0;
          liveStakePerNumber = baseUnit;
        } else {
          liveLosses++;
          liveCurrentLosingStreak++;
          if (liveCurrentLosingStreak > liveWorstStreak) {
            liveWorstStreak = liveCurrentLosingStreak;
          }

          liveProfit -= totalStake;

          liveMartingaleLossCount += 1;
          if (liveMartingaleLossCount >= LOSS_RESET_MARTINGALE) {
            liveStakePerNumber = baseUnit;
            liveMartingaleLossCount = 0;
          } else {
            liveStakePerNumber = stakePerNumberNow * 2;
          }
        }
        updateStatsUI();
      }

      // 2) Add new spin to history
      spinsLive.push(v);
      spinInput.value = "";
      updateHistoryUI();

      // 3) Update adaptive parameters from all data (including this new spin)
      maybeUpdateAdaptiveParamsFromSpins(spinsLive);

      // 4) Compute new prediction for NEXT spin with updated parameters
      const pred = csPrediction(spinsLive, AUTO_PARAMS);
      lastPrediction = pred;
      renderRecommendation(pred);
    }

    function onResetSpins() {
      spinsLive.length = 0;
      lastPrediction = null;
      liveTotalBets = 0;
      liveWins = 0;
      liveLosses = 0;
      liveCurrentLosingStreak = 0;
      liveWorstStreak = 0;
      liveProfit = 0;
      liveStakePerNumber = null;
      liveMartingaleLossCount = 0;

      AUTO_PARAMS = JSON.parse(JSON.stringify(INITIAL_PARAMS));
      ["CW","CCW"].forEach(dir => {
        const st = adaptiveState[dir];
        st.n = 0; st.s11 = st.s12 = st.s22 = 0;
        st.s1y = st.s2y = 0;
        st.errMean = 0;
      });
      updateParamBadge();

      updateHistoryUI();
      updateStatsUI();
      renderRecommendation(null);
    }

    addSpinBtn.addEventListener("click", onAddSpin);
    resetSpinsBtn.addEventListener("click", onResetSpins);
    spinInput.addEventListener("keyup", (e) => {
      if (e.key === "Enter") onAddSpin();
    });

    // ---------- BULK LOAD INTO LIVE MODE (WITH ADAPTATION) ----------

    const bulkLiveInput = document.getElementById("bulkLiveInput");
    const loadBulkLiveBtn = document.getElementById("loadBulkLiveBtn");

    loadBulkLiveBtn.addEventListener("click", () => {
      const spins = parseSpinText(bulkLiveInput.value);
      if (spins.length < 2) {
        alert("Please paste at least 2 valid spins (0–36).");
        return;
      }

      const baseUnit = getBaseUnit();

      // Reset all live + adaptive stats
      spinsLive.length = 0;
      liveTotalBets = 0;
      liveWins = 0;
      liveLosses = 0;
      liveCurrentLosingStreak = 0;
      liveWorstStreak = 0;
      liveProfit = 0;
      liveStakePerNumber = null;
      liveMartingaleLossCount = 0;
      AUTO_PARAMS = JSON.parse(JSON.stringify(INITIAL_PARAMS));
      ["CW","CCW"].forEach(dir => {
        const st = adaptiveState[dir];
        st.n = 0; st.s11 = st.s12 = st.s22 = 0;
        st.s1y = st.s2y = 0;
        st.errMean = 0;
      });
      updateParamBadge();

      let history = [];
      let lastPredLocal = null;

      for (let i = 0; i < spins.length; i++) {
        const result = spins[i];

        if (lastPredLocal && lastPredLocal.shouldBet) {
          liveTotalBets++;

          const neighbours = lastPredLocal.neighbours || [];
          const numbersCovered = neighbours.length;
          const stakePerNumberNow = (liveStakePerNumber == null) ? baseUnit : liveStakePerNumber;
          const totalStake = stakePerNumberNow * numbersCovered;

          const hit = neighbours.includes(result);

          if (hit) {
            const winReturn = stakePerNumberNow * 36;
            const profit = winReturn - totalStake;
            liveProfit += profit;

            liveWins++;
            liveCurrentLosingStreak = 0;
            liveMartingaleLossCount = 0;
            liveStakePerNumber = baseUnit;
          } else {
            liveLosses++;
            liveCurrentLosingStreak++;
            if (liveCurrentLosingStreak > liveWorstStreak) {
              liveWorstStreak = liveCurrentLosingStreak;
            }
            liveProfit -= totalStake;

            liveMartingaleLossCount += 1;
            if (liveMartingaleLossCount >= LOSS_RESET_MARTINGALE) {
              liveStakePerNumber = baseUnit;
              liveMartingaleLossCount = 0;
            } else {
              liveStakePerNumber = stakePerNumberNow * 2;
            }
          }
        }

        history.push(result);
        spinsLive.push(result);

        // update adaptive params with this new spin
        maybeUpdateAdaptiveParamsFromSpins(history);

        // compute prediction for next spin (using updated params)
        lastPredLocal = csPrediction(history, AUTO_PARAMS);
      }

      lastPrediction = lastPredLocal;

      updateHistoryUI();
      updateStatsUI();
      renderRecommendation(lastPredLocal);

      alert(`Loaded ${spins.length} spins into Live Mode (adaptive model updated).`);
    });

    // ---------- SIMULATOR (NO ADAPTATION INSIDE) ----------

    const simInput = document.getElementById("simInput");
    const runSimBtn = document.getElementById("runSimBtn");
    const clearSimBtn = document.getElementById("clearSimBtn");
    const simResults = document.getElementById("simResults");
    const simSpinsEl = document.getElementById("simSpins");
    const simTotalBetsEl = document.getElementById("simTotalBets");
    const simWinsEl = document.getElementById("simWins");
    const simLossesEl = document.getElementById("simLosses");
    const simHitRateEl = document.getElementById("simHitRate");
    const simWorstStreakEl = document.getElementById("simWorstStreak");
    const simProfitEl = document.getElementById("simProfit");
    const simNotesEl = document.getElementById("simNotes");

    function simulateSpinsArrayWithParams(spins, baseUnit, params) {
      if (spins.length < 2) {
        return null;
      }

      let totalBets = 0;
      let wins = 0;
      let losses = 0;
      let currentStreak = 0;
      let worstStreak = 0;

      let simProfit = 0;
      let stakePerNumber = null;
      let martingaleLossCount = 0;

      let history = [];
      let lastPred = null;

      for (let i = 0; i < spins.length; i++) {
        const result = spins[i];

        if (lastPred && lastPred.shouldBet) {
          totalBets++;

          const neighbours = lastPred.neighbours || [];
          const numbersCovered = neighbours.length;
          const stakeNow = (stakePerNumber == null) ? baseUnit : stakePerNumber;
          const totalStake = stakeNow * numbersCovered;

          const hit = neighbours.includes(result);
          if (hit) {
            const winReturn = stakeNow * 36;
            const profit = winReturn - totalStake;
            simProfit += profit;

            wins++;
            currentStreak = 0;
            martingaleLossCount = 0;
            stakePerNumber = baseUnit;
          } else {
            const profit = -totalStake;
            simProfit += profit;

            losses++;
            currentStreak++;
            if (currentStreak > worstStreak) worstStreak = currentStreak;

            martingaleLossCount += 1;
            if (martingaleLossCount >= LOSS_RESET_MARTINGALE) {
              stakePerNumber = baseUnit;
              martingaleLossCount = 0;
            } else {
              stakePerNumber = stakeNow * 2;
            }
          }
        }

        history.push(result);
        lastPred = csPrediction(history, params);
      }

      const hitRate = totalBets ? (wins / totalBets) * 100 : null;

      return {
        spinsCount: spins.length,
        totalBets,
        wins,
        losses,
        hitRate,
        worstStreak,
        profit: simProfit
      };
    }

    function runSimulation() {
      const spins = parseSpinText(simInput.value);
      if (spins.length < 2) {
        alert("Please paste at least 2 valid spins (0–36).");
        return;
      }

      const baseUnit = getBaseUnit();
      const paramsSnapshot = JSON.parse(JSON.stringify(AUTO_PARAMS)); // snapshot per-dir params
      const res = simulateSpinsArrayWithParams(spins, baseUnit, paramsSnapshot);
      if (!res) {
        alert("Not enough spins to simulate.");
        return;
      }

      simResults.style.display = "block";
      simSpinsEl.textContent = res.spinsCount;
      simTotalBetsEl.textContent = res.totalBets;
      simWinsEl.textContent = res.wins;
      simLossesEl.textContent = res.losses;
      if (res.totalBets === 0) {
        simHitRateEl.textContent = "–";
      } else {
        simHitRateEl.textContent = res.hitRate.toFixed(1) + "%";
      }
      simWorstStreakEl.textContent = res.worstStreak;
      simProfitEl.textContent = formatMoney(res.profit);
      simNotesEl.textContent =
        `Simulation using snapshot: ` +
        `CW(a=${paramsSnapshot.CW.aFixed.toFixed(2)}, b=${paramsSnapshot.CW.bFixed.toFixed(2)}, shift=${paramsSnapshot.CW.extraShift}); ` +
        `CCW(a=${paramsSnapshot.CCW.aFixed.toFixed(2)}, b=${paramsSnapshot.CCW.bFixed.toFixed(2)}, shift=${paramsSnapshot.CCW.extraShift}). ` +
        `No adaptation inside this run.`;
    }

    function clearSimulation() {
      simInput.value = "";
      simResults.style.display = "none";
    }

    runSimBtn.addEventListener("click", runSimulation);
    clearSimBtn.addEventListener("click", clearSimulation);

    // ---------- INITIALISE UI ----------

    updateHistoryUI();
    updateStatsUI();
    updateParamBadge();
    renderRecommendation(null);
  </script>
</body>
</html>
