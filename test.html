<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Roulette Predictor</title>
    <style>
        /* [Keep all your existing styles the same] */
        .safety-mechanism {
            background: #fff3cd;
            padding: 10px;
            border-left: 4px solid #ffc107;
            margin: 10px 0;
            font-weight: bold;
        }
        .emergency-alert {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-left: 4px solid #dc3545;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <!-- [Keep all your existing HTML structure the same] -->

    <script>
        // European roulette wheel layout
        const WHEEL = [0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26];
        
        // Configuration with strict loss prevention
        const MAX_LOSS_STREAK = 6;
        const SAFETY_THRESHOLD = 3;
        const SECTOR_SIZE = 6;
        const MIN_HISTORY = 10;
        const EMERGENCY_CHANGE_AFTER = 4;

        // Game state
        let numbers = [];
        let predictions = [];
        let lossStreak = 0;
        let longestLossStreak = 0;
        let currentPrediction = null;
        let safetyMode = false;
        let emergencyMode = false;
        let sectorHits = new Array(Math.ceil(WHEEL.length / SECTOR_SIZE)).fill(0);
        let lastSectorHit = null;
        let strategyPerformance = {
            standard: { wins: 0, losses: 0 },
            safety: { wins: 0, losses: 0 },
            emergency: { wins: 0, losses: 0 }
        };

        // Initialize on load
        window.onload = function() {
            loadData();
        };

        // [Keep your existing loadData(), saveData(), and clearData() functions]

        // Improved prediction logic with multiple safety nets
        function makeNextPrediction() {
            if (numbers.length < MIN_HISTORY) {
                currentPrediction = null;
                updateDisplay();
                return;
            }

            // Check if we need to activate safety mechanisms
            if (lossStreak >= EMERGENCY_CHANGE_AFTER) {
                emergencyMode = true;
                safetyMode = true;
            } else if (lossStreak >= SAFETY_THRESHOLD) {
                safetyMode = true;
            } else {
                safetyMode = false;
                emergencyMode = false;
            }

            const prediction = generatePrediction();
            currentPrediction = {
                ...prediction,
                safetyMode,
                emergencyMode,
                streak: lossStreak,
                timestamp: new Date()
            };
            
            predictions.push(currentPrediction);
            saveData();
            updateDisplay();
        }

        function generatePrediction() {
            const lastNum = numbers[numbers.length-1];
            const lastIdx = WHEEL.indexOf(lastNum);
            
            if (emergencyMode) {
                // Emergency mode - completely different approach
                return generateEmergencyPrediction(lastNum);
            } else if (safetyMode) {
                // Safety mode - conservative prediction
                return generateSafetyPrediction(lastNum);
            } else {
                // Standard prediction
                return generateStandardPrediction(lastNum);
            }
        }

        function generateStandardPrediction(lastNum) {
            const lastIdx = WHEEL.indexOf(lastNum);
            
            // 1. Find the most common recent step pattern
            const stepPattern = analyzeStepPattern();
            const predictedStep = stepPattern.mostCommon;
            
            // 2. Get cold sectors to avoid
            const coldSectors = getColdSectors();
            const coldNumbers = getNumbersInSectors(coldSectors);
            
            // 3. Generate prediction avoiding cold numbers
            let predictedIdx, predictedNumber;
            let attempts = 0;
            
            do {
                predictedIdx = (lastIdx + predictedStep + attempts) % 37;
                predictedNumber = WHEEL[predictedIdx];
                attempts++;
            } while (coldNumbers.includes(predictedNumber) && attempts < 37);
            
            return {
                predictedFor: lastNum,
                predicted: predictedNumber,
                neighbors: getNeighbors(predictedNumber),
                strategy: "Standard Pattern"
            };
        }

        function generateSafetyPrediction(lastNum) {
            // Use sector-based prediction with recent bias
            const hotSectors = getHotSectors(2); // Get 2 hottest sectors
            const hotNumbers = getNumbersInSectors(hotSectors);
            
            // Find the most recent hot number
            let lastHotNum = lastNum;
            for (let i = numbers.length-2; i >= 0; i--) {
                if (hotNumbers.includes(numbers[i])) {
                    lastHotNum = numbers[i];
                    break;
                }
            }
            
            // Predict continuation in hot sector
            const lastHotIdx = WHEEL.indexOf(lastHotNum);
            const step = analyzeStepPattern().medianStep;
            const predictedIdx = (lastHotIdx + step) % 37;
            const predictedNumber = WHEEL[predictedIdx];
            
            return {
                predictedFor: lastNum,
                predicted: predictedNumber,
                neighbors: getNeighbors(predictedNumber),
                strategy: "Safety Hot Sectors"
            };
        }

        function generateEmergencyPrediction(lastNum) {
            // Completely different approach - anti-pattern
            const coldSectors = getColdSectors();
            const coldNumbers = getNumbersInSectors(coldSectors);
            
            // Find the least recent number
            const leastRecent = findLeastRecentNumber();
            const leastRecentIdx = WHEEL.indexOf(leastRecent);
            
            // Predict opposite of normal pattern
            const stepPattern = analyzeStepPattern();
            const antiStep = 37 - stepPattern.medianStep;
            const predictedIdx = (leastRecentIdx + antiStep) % 37;
            const predictedNumber = WHEEL[predictedIdx];
            
            return {
                predictedFor: lastNum,
                predicted: predictedNumber,
                neighbors: getNeighbors(predictedNumber),
                strategy: "Emergency Anti-Pattern"
            };
        }

        // Helper functions
        function analyzeStepPattern() {
            if (numbers.length < 2) return { mostCommon: 1, medianStep: 1 };
            
            const steps = [];
            for (let i = 1; i < Math.min(numbers.length, 10); i++) {
                const prevIdx = WHEEL.indexOf(numbers[i-1]);
                const currIdx = WHEEL.indexOf(numbers[i]);
                steps.push((currIdx - prevIdx + 37) % 37);
            }
            
            // Find most common step
            const frequency = {};
            steps.forEach(step => {
                frequency[step] = (frequency[step] || 0) + 1;
            });
            
            const mostCommon = parseInt(Object.entries(frequency)
                .sort((a, b) => b[1] - a[1])[0][0]);
            
            // Calculate median step
            const median = arr => {
                const mid = Math.floor(arr.length / 2);
                const nums = [...arr].sort((a, b) => a - b);
                return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
            };
            
            return {
                mostCommon,
                medianStep: Math.round(median(steps))
            };
        }

        function getHotSectors(count = 1) {
            const avgHits = numbers.length / sectorHits.length;
            return [...sectorHits.entries()]
                .sort((a, b) => b[1] - a[1])
                .slice(0, count)
                .map(([sector]) => sector);
        }

        function getColdSectors() {
            const avgHits = numbers.length / sectorHits.length;
            return [...sectorHits.entries()]
                .filter(([_, hits]) => hits < avgHits * 0.7)
                .sort((a, b) => a[1] - b[1])
                .slice(0, 2)
                .map(([sector]) => sector);
        }

        function getNumbersInSectors(sectors) {
            const numbersInSectors = [];
            sectors.forEach(sector => {
                const startIdx = sector * SECTOR_SIZE;
                const endIdx = Math.min(startIdx + SECTOR_SIZE, WHEEL.length);
                for (let i = startIdx; i < endIdx; i++) {
                    numbersInSectors.push(WHEEL[i]);
                }
            });
            return numbersInSectors;
        }

        function findLeastRecentNumber() {
            // Find number that hasn't appeared in the longest time
            const numCounts = {};
            numbers.forEach((num, idx) => {
                numCounts[num] = idx; // Store last occurrence index
            });
            
            return Object.entries(numCounts)
                .sort((a, b) => a[1] - b[1])[0][0];
        }

        // [Keep your existing update functions, but add safety mode indicators]
        function updateCurrentPrediction() {
            const predictionDiv = document.getElementById("currentPrediction");
            const neighborsDiv = document.getElementById("neighborsDisplay");
            
            if (numbers.length > 0 && currentPrediction) {
                let modeIndicator = '';
                if (currentPrediction.emergencyMode) {
                    modeIndicator = '<div class="emergency-alert">EMERGENCY MODE: Using anti-pattern prediction</div>';
                } else if (currentPrediction.safetyMode) {
                    modeIndicator = '<div class="safety-mechanism">SAFETY MODE: Using conservative prediction</div>';
                }
                
                predictionDiv.innerHTML = `
                    ${modeIndicator}
                    <p><strong>Last number:</strong> ${numbers[numbers.length-1]}</p>
                    <p><strong>Predicted number:</strong> ${currentPrediction.predicted}</p>
                    <p><strong>Strategy:</strong> ${currentPrediction.strategy}</p>
                `;
                
                neighborsDiv.innerHTML = `
                    <p><strong>Bet on these 19 numbers:</strong></p>
                    <div class="neighbors">
                        ${currentPrediction.neighbors.map(num => `
                            <span class="neighbor ${num === currentPrediction.predicted ? 'predicted-number' : ''}">
                                ${num}
                            </span>
                        `).join('')}
                    </div>
                `;
            }
        }

        // [Keep your existing checkPrediction function, but update it to track strategy performance]
        function checkPrediction(actualNumber) {
            const lastPrediction = predictions[predictions.length-1];
            const isCorrect = lastPrediction.neighbors.includes(actualNumber);
            
            // Update performance tracking
            const strategyType = lastPrediction.emergencyMode ? 'emergency' : 
                               lastPrediction.safetyMode ? 'safety' : 'standard';
            
            if (isCorrect) {
                strategyPerformance[strategyType].wins++;
                lossStreak = 0;
            } else {
                strategyPerformance[strategyType].losses++;
                lossStreak++;
                if (lossStreak > longestLossStreak) {
                    longestLossStreak = lossStreak;
                }
            }
            
            // Update prediction record
            lastPrediction.actual = actualNumber;
            lastPrediction.isCorrect = isCorrect;
            lastPrediction.streak = lossStreak;
        }

        // [Keep your other existing functions like getNeighbors, updateStats, etc.]
    </script>
</body>
</html>
