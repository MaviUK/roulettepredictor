<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Roulette Analyst</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 300px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
        }
        button:hover {
            background-color: #2980b9;
        }
        #exportMartingaleBtn {
            background-color: #27ae60;
            margin-top: 10px;
        }
        #exportMartingaleBtn:hover {
            background-color: #219653;
        }
        input[type="number"], input[type="text"], select {
            padding: 8px;
            margin: 5px 0;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 8px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .history-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        .history-item {
            background: #e74c3c;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        .history-item.red {
            background: #e74c3c;
        }
        .history-item.black {
            background: #2c3e50;
        }
        .history-item.green {
            background: #27ae60;
        }
        .predictions {
            text-align: center;
            margin: 20px 0;
        }
        .predicted-number {
            font-size: 2em;
            font-weight: bold;
            color: #e74c3c;
            margin: 10px 0;
        }
        .neighbors {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
        }
        .neighbor {
            padding: 3px 8px;
            background: #3498db;
            color: white;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .wheel-display {
            text-align: center;
            margin: 20px 0;
        }
        .wheel {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: #005a00;
            margin: 0 auto;
            position: relative;
            border: 5px solid #2c3e50;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }
        .wheel-number {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            color: white;
            transform-origin: center;
            transition: box-shadow 0.3s ease;
        }
        .wheel-number.green {
            background: #008000;
        }
        .wheel-number.red {
            background: #e74c3c;
        }
        .wheel-number.black {
            background: #2c3e50;
        }
        .wheel-center {
            position: absolute;
            width: 60px;
            height: 60px;
            background: #f5f5f5;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid #2c3e50;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .wheel-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background: gold;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        .wheel-prediction-range {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            border-radius: 50%;
            pointer-events: none;
        }
        .stats {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        .selected-numbers {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }
        .selected-number {
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9em;
        }
        .win {
            background-color: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
        }
        .loss {
            background-color: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
        }
        .direction-stats {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }
        .direction-stat {
            flex: 1;
            padding: 10px;
            background: #ecf0f1;
            border-radius: 5px;
        }
        .travel-pattern {
            margin-top: 10px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 5px;
        }
        .pattern-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        .neighbor-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 5px;
        }
        .neighbor-group-label {
            font-size: 0.8em;
            margin-bottom: 3px;
            color: #7f8c8d;
        }
        .neighbor-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 3px;
            max-width: 200px;
        }
        .martingale-panel {
            background: #fff8e1;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        .martingale-stats {
            margin-top: 10px;
        }
        .profit {
            color: #27ae60;
            font-weight: bold;
        }
        .loss {
            color: #e74c3c;
            font-weight: bold;
        }
        .current-bet {
            font-weight: bold;
            color: #3498db;
        }
        .warning {
            color: #e67e22;
            font-weight: bold;
        }
        .prediction-model {
            margin-top: 20px;
            padding: 15px;
            background: #f0f7ff;
            border-radius: 5px;
        }
        .model-stats {
            margin-top: 10px;
        }
        .model-accuracy {
            font-weight: bold;
            color: #2980b9;
        }
        .sector-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        .sector {
            padding: 5px;
            border-radius: 3px;
            font-size: 0.8em;
            text-align: center;
            flex: 1;
            min-width: 60px;
        }
        .hot-sector {
            background-color: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
        }
        .cold-sector {
            background-color: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
        }
    </style>
</head>
<body>
    <h1>Enhanced Roulette Analyst</h1>
    <p>Dynamic Prediction System with Pattern Recognition</p>
    
    <div class="container">
        <div class="panel">
            <h2>Data Input</h2>
            
            <h3>Single Spin Entry</h3>
            <div>
                <input type="number" id="spinInput" placeholder="Enter number (0-36)" min="0" max="36">
                <button id="addSpinBtn">Add Spin</button>
            </div>
            
            <h3>Batch Input</h3>
            <textarea id="batchInput" placeholder="Enter numbers separated by commas or spaces (oldest first)"></textarea>
            <button id="batchAddBtn">Add Multiple Spins</button>
            
            <div class="martingale-panel">
                <h3>Smart Betting System</h3>
                <div>
                    <label for="baseBet">Base Bet per Number:</label>
                    <input type="number" id="baseBet" min="0.5" value="1" step="0.5">
                </div>
                <div>
                    <label for="bankroll">Starting Bankroll:</label>
                    <input type="number" id="bankroll" min="10" value="100" step="1">
                </div>
                <div>
                    <label for="maxLosses">Max Losses in a Row:</label>
                    <input type="number" id="maxLosses" min="1" max="8" value="6">
                    <span class="warning">(System will reset after this many losses)</span>
                </div>
                <button id="resetMartingaleBtn">Reset System</button>
                <button id="exportMartingaleBtn">Download Betting Data</button>
                
                <div class="martingale-stats">
                    <div class="stats-row">
                        <span>Current Bet per Number:</span>
                        <span id="currentBet" class="current-bet">1</span>
                    </div>
                    <div class="stats-row">
                        <span>Current Bankroll:</span>
                        <span id="currentBankroll">100</span>
                    </div>
                    <div class="stats-row">
                        <span>Total Profit/Loss:</span>
                        <span id="totalProfitLoss">0</span>
                    </div>
                    <div class="stats-row">
                        <span>Current Streak:</span>
                        <span id="currentStreak">0</span>
                    </div>
                    <div class="stats-row">
                        <span>Longest Losing Streak:</span>
                        <span id="longestStreak">0</span>
                    </div>
                    <div class="stats-row">
                        <span>Total Bets Won:</span>
                        <span id="betsWon">0</span>
                    </div>
                    <div class="stats-row">
                        <span>Total Bets Lost:</span>
                        <span id="betsLost">0</span>
                    </div>
                </div>
            </div>

            <div class="prediction-model">
                <h3>Prediction Model</h3>
                <div>
                    <label for="modelSensitivity">Model Sensitivity:</label>
                    <select id="modelSensitivity">
                        <option value="1">Low (Conservative)</option>
                        <option value="2" selected>Medium (Balanced)</option>
                        <option value="3">High (Aggressive)</option>
                    </select>
                </div>
                <div>
                    <label for="maxConsecutiveLosses">Max Consecutive Losses:</label>
                    <input type="number" id="maxConsecutiveLosses" min="1" max="10" value="6">
                </div>
                <button id="resetModelBtn">Reset Model</button>
                
                <div class="model-stats">
                    <div class="stats-row">
                        <span>Model Accuracy:</span>
                        <span id="modelAccuracy" class="model-accuracy">0%</span>
                    </div>
                    <div class="stats-row">
                        <span>Current Streak:</span>
                        <span id="modelStreak">0</span>
                    </div>
                    <div class="stats-row">
                        <span>Consecutive Losses:</span>
                        <span id="modelConsecutiveLosses">0</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Analysis</h2>
            <div class="wheel-display">
                <div class="wheel" id="rouletteWheel">
                    <!-- Wheel numbers will be inserted here by JavaScript -->
                    <div class="wheel-center">0</div>
                </div>
            </div>
            
            <div class="predictions">
                <h3>Prediction Settings</h3>
                <div>
                    <label for="neighborCount">Number of Neighbors (each side):</label>
                    <select id="neighborCount">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8">8</option>
                        <option value="9" selected>9</option>
                    </select>
                </div>
                
                <h3>Predicted Landing Zone</h3>
                <div class="predicted-number" id="predictedNumber">-</div>
                <div class="neighbors">
                    <div class="neighbor-group">
                        <div class="neighbor-group-label" id="leftNeighborLabel">Left 9 (CCW)</div>
                        <div class="neighbor-container" id="leftNeighbors"></div>
                    </div>
                    <div class="neighbor-group">
                        <div class="neighbor-group-label" id="rightNeighborLabel">Right 9 (CW)</div>
                        <div class="neighbor-container" id="rightNeighbors"></div>
                    </div>
                </div>
            </div>

            <div class="stats">
                <h3>Current Selection</h3>
                <div class="selected-numbers" id="selectedNumbers">
                    <div>No active prediction</div>
                </div>
                
                <h3>Performance Tracking</h3>
                <div class="stats-row">
                    <span>Total Spins:</span>
                    <span id="totalSpins">0</span>
                </div>
                
                <div class="direction-stats">
                    <div class="direction-stat">
                        <h4>Clockwise (CW)</h4>
                        <div class="stats-row">
                            <span>Wins:</span>
                            <span id="cwWins">0</span>
                        </div>
                        <div class="stats-row">
                            <span>Win %:</span>
                            <span id="cwWinPct">0%</span>
                        </div>
                        <div class="stats-row">
                            <span>Avg Travel:</span>
                            <span id="cwAvgTravel">0</span>
                        </div>
                    </div>
                    
                    <div class="direction-stat">
                        <h4>Counter-Clockwise (CCW)</h4>
                        <div class="stats-row">
                            <span>Wins:</span>
                            <span id="ccwWins">0</span>
                        </div>
                        <div class="stats-row">
                            <span>Win %:</span>
                            <span id="ccwWinPct">0%</span>
                        </div>
                        <div class="stats-row">
                            <span>Avg Travel:</span>
                            <span id="ccwAvgTravel">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="travel-pattern">
                    <h4>Recent Travel Patterns</h4>
                    <div id="travelPatterns">
                        <div class="pattern-row">
                            <span>Direction</span>
                            <span>From</span>
                            <span>To</span>
                            <span>Pockets</span>
                        </div>
                    </div>
                </div>
                
                <div class="sector-analysis">
                    <h4>Sector Performance</h4>
                    <div class="sector-stats" id="sectorStats"></div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Spin History</h2>
            <div class="history-controls">
                <button id="clearHistoryBtn">Clear History</button>
                <button id="exportHistoryBtn">Export Data</button>
                <span id="historyCount">0 spins recorded</span>
            </div>
            <div id="historyList" class="history-list"></div>
        </div>
    </div>

    <script>
        // European wheel layout (single zero)
        const wheelLayout = [
            0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26
        ];

        // Red numbers for color assignment
        const redNumbers = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36];

        // Enhanced application state
        let spinHistory = [];
        let currentDirection = 'cw'; // cw = clockwise, ccw = counter-clockwise
        let currentPrediction = null;
        let currentSelection = [];
        let stats = {
            total: 0,
            cw: {
                wins: 0,
                total: 0,
                travelDistances: []
            },
            ccw: {
                wins: 0,
                total: 0,
                travelDistances: []
            },
            travelPatterns: [],
            sectorPerformance: Array(8).fill(0).map(() => ({ hits: 0, appearances: 0 })),
            lastTenDirections: []
        };

        // Martingale system state
        let martingale = {
            baseBet: 1,
            currentBet: 1,
            bankroll: 100,
            totalProfitLoss: 0,
            currentStreak: 0,
            longestStreak: 0,
            betsWon: 0,
            betsLost: 0,
            maxLosses: 6,
            active: false
        };

        // Martingale transaction history
        let martingaleTransactions = [];

        // Prediction model state
        let predictionModel = {
            sensitivity: 2, // 1=low, 2=medium, 3=high
            maxConsecutiveLosses: 6,
            consecutiveLosses: 0,
            currentStreak: 0,
            totalPredictions: 0,
            correctPredictions: 0,
            cwAvgTravel: 0,
            ccwAvgTravel: 0,
            cwTravelCount: 0,
            ccwTravelCount: 0
        };

        // DOM elements
        const spinInput = document.getElementById('spinInput');
        const addSpinBtn = document.getElementById('addSpinBtn');
        const batchInput = document.getElementById('batchInput');
        const batchAddBtn = document.getElementById('batchAddBtn');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        const exportHistoryBtn = document.getElementById('exportHistoryBtn');
        const exportMartingaleBtn = document.getElementById('exportMartingaleBtn');
        const historyCountSpan = document.getElementById('historyCount');
        const historyListDiv = document.getElementById('historyList');
        const predictedNumberDiv = document.getElementById('predictedNumber');
        const leftNeighborsDiv = document.getElementById('leftNeighbors');
        const rightNeighborsDiv = document.getElementById('rightNeighbors');
        const selectedNumbersDiv = document.getElementById('selectedNumbers');
        const totalSpinsSpan = document.getElementById('totalSpins');
        const cwWinsSpan = document.getElementById('cwWins');
        const cwWinPctSpan = document.getElementById('cwWinPct');
        const cwAvgTravelSpan = document.getElementById('cwAvgTravel');
        const ccwWinsSpan = document.getElementById('ccwWins');
        const ccwWinPctSpan = document.getElementById('ccwWinPct');
        const ccwAvgTravelSpan = document.getElementById('ccwAvgTravel');
        const travelPatternsDiv = document.getElementById('travelPatterns');
        const rouletteWheel = document.getElementById('rouletteWheel');
        const neighborCountSelect = document.getElementById('neighborCount');
        const sectorStatsDiv = document.getElementById('sectorStats');
        
        // Martingale elements
        const baseBetInput = document.getElementById('baseBet');
        const bankrollInput = document.getElementById('bankroll');
        const maxLossesInput = document.getElementById('maxLosses');
        const resetMartingaleBtn = document.getElementById('resetMartingaleBtn');
        const currentBetSpan = document.getElementById('currentBet');
        const currentBankrollSpan = document.getElementById('currentBankroll');
        const totalProfitLossSpan = document.getElementById('totalProfitLoss');
        const currentStreakSpan = document.getElementById('currentStreak');
        const longestStreakSpan = document.getElementById('longestStreak');
        const betsWonSpan = document.getElementById('betsWon');
        const betsLostSpan = document.getElementById('betsLost');

        // Prediction model elements
        const modelSensitivitySelect = document.getElementById('modelSensitivity');
        const maxConsecutiveLossesInput = document.getElementById('maxConsecutiveLosses');
        const resetModelBtn = document.getElementById('resetModelBtn');
        const modelAccuracySpan = document.getElementById('modelAccuracy');
        const modelStreakSpan = document.getElementById('modelStreak');
        const modelConsecutiveLossesSpan = document.getElementById('modelConsecutiveLosses');

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            createWheel();
            updateHistoryDisplay();
            updateStatsDisplay();
            updateMartingaleDisplay();
            updateModelDisplay();
            updateSectorStats();
            
            // Load from localStorage if available
            loadFromLocalStorage();
            
            // Add event listeners
            neighborCountSelect.addEventListener('change', () => {
                if (spinHistory.length > 0) {
                    generatePrediction();
                }
            });
            
            maxLossesInput.addEventListener('change', updateMartingaleSettings);
            modelSensitivitySelect.addEventListener('change', updateModelSettings);
            maxConsecutiveLossesInput.addEventListener('change', updateModelSettings);
            resetModelBtn.addEventListener('click', resetModel);
        });

        // Create the visual roulette wheel
        function createWheel() {
            const radius = 140;
            const centerX = 150;
            const centerY = 150;
            const angleIncrement = (2 * Math.PI) / wheelLayout.length;
            
            wheelLayout.forEach((number, index) => {
                const angle = index * angleIncrement - Math.PI / 2; // Offset by 90 degrees to start at top
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const numberElement = document.createElement('div');
                numberElement.className = `wheel-number ${getColorForNumber(number)}`;
                numberElement.textContent = number;
                numberElement.style.left = `${x - 15}px`;
                numberElement.style.top = `${y - 15}px`;
                numberElement.style.transform = `rotate(${angle + Math.PI/2}rad)`;
                
                rouletteWheel.appendChild(numberElement);
            });
        }

        // Event listeners
        addSpinBtn.addEventListener('click', addSingleSpin);
        batchAddBtn.addEventListener('click', addBatchSpins);
        clearHistoryBtn.addEventListener('click', clearHistory);
        exportHistoryBtn.addEventListener('click', exportHistory);
        exportMartingaleBtn.addEventListener('click', exportMartingaleData);
        spinInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addSingleSpin();
        });
        
        // Martingale controls
        baseBetInput.addEventListener('change', updateMartingaleSettings);
        bankrollInput.addEventListener('change', updateMartingaleSettings);
        resetMartingaleBtn.addEventListener('click', resetMartingale);

        // Core functions
        function addSingleSpin() {
            const number = parseInt(spinInput.value);
            if (isNaN(number) || number < 0 || number > 36) {
                alert('Please enter a valid number between 0 and 36');
                return;
            }
            
            recordSpin(number);
            spinInput.value = '';
            spinInput.focus();
        }

        function addBatchSpins() {
            const input = batchInput.value.trim();
            if (!input) return;
            
            const numbers = input.split(/[\s,]+/)
                .map(n => parseInt(n))
                .filter(n => !isNaN(n) && n >= 0 && n <= 36);
            
            if (numbers.length === 0) {
                alert('No valid numbers found');
                return;
            }
            
            numbers.forEach(number => {
                recordSpin(number);
            });
            
            batchInput.value = '';
        }

        function recordSpin(number) {
            const color = getColorForNumber(number);
            const direction = currentDirection;
            
            // Calculate travel distance if we have previous spins
            let travelDistance = 0;
            if (spinHistory.length > 0) {
                const lastSpin = spinHistory[spinHistory.length - 1];
                const lastIndex = wheelLayout.indexOf(lastSpin.number);
                const currentIndex = wheelLayout.indexOf(number);
                
                if (lastSpin.direction === 'cw') {
                    travelDistance = (lastIndex - currentIndex + wheelLayout.length) % wheelLayout.length;
                } else {
                    travelDistance = (currentIndex - lastIndex + wheelLayout.length) % wheelLayout.length;
                }
                
                // Record travel pattern
                stats.travelPatterns.unshift({
                    from: lastSpin.number,
                    to: number,
                    direction: lastSpin.direction,
                    distance: travelDistance
                });
                
                if (stats.travelPatterns.length > 5) {
                    stats.travelPatterns.pop();
                }
            }
            
            // Add to history
            spinHistory.push({
                number,
                color,
                direction,
                timestamp: new Date().toISOString()
            });
            
            // Update sector stats
            const index = wheelLayout.indexOf(number);
            const sector = Math.floor(index / 5); // 8 sectors of ~5 numbers each
            stats.sectorPerformance[sector].appearances++;
            if (currentSelection.includes(number)) {
                stats.sectorPerformance[sector].hits++;
            }
            
            // Track direction patterns
            stats.lastTenDirections.push(direction);
            if (stats.lastTenDirections.length > 10) {
                stats.lastTenDirections.shift();
            }
            
            // Update direction-specific stats
            if (direction === 'cw') {
                stats.cw.total++;
                stats.cw.travelDistances.push(travelDistance);
            } else {
                stats.ccw.total++;
                stats.ccw.travelDistances.push(travelDistance);
            }
            
            // Check if this number was in our current selection
            if (currentSelection.length > 0) {
                updateStats(number);
                updateMartingaleStats(number);
                updateModelResults(number);
            }
            
            // Alternate direction for next spin
            currentDirection = currentDirection === 'cw' ? 'ccw' : 'cw';
            
            // Generate new prediction
            generatePrediction();
            
            updateHistoryDisplay();
            updateStatsDisplay();
            updateWheelDisplay();
            updateTravelPatternsDisplay();
            updateMartingaleDisplay();
            updateModelDisplay();
            updateSectorStats();
            
            // Save to localStorage
            saveToLocalStorage();
        }

        function updateModelStatistics(lastSpin, currentNumber, travelDistance) {
            if (lastSpin.direction === 'cw') {
                predictionModel.cwAvgTravel = 
                    (predictionModel.cwAvgTravel * predictionModel.cwTravelCount + travelDistance) / 
                    (predictionModel.cwTravelCount + 1);
                predictionModel.cwTravelCount++;
            } else {
                predictionModel.ccwAvgTravel = 
                    (predictionModel.ccwAvgTravel * predictionModel.ccwTravelCount + travelDistance) / 
                    (predictionModel.ccwTravelCount + 1);
                predictionModel.ccwTravelCount++;
            }
        }

        function updateModelResults(number) {
            predictionModel.totalPredictions++;
            
            const wasCorrect = currentSelection.includes(number);
            if (wasCorrect) {
                predictionModel.correctPredictions++;
                predictionModel.currentStreak++;
                predictionModel.consecutiveLosses = 0;
            } else {
                predictionModel.currentStreak = 0;
                predictionModel.consecutiveLosses++;
                
                if (predictionModel.consecutiveLosses >= predictionModel.maxConsecutiveLosses) {
                    alert(`Prediction model reached ${predictionModel.maxConsecutiveLosses} consecutive losses! Adjusting sensitivity.`);
                    predictionModel.consecutiveLosses = 0;
                    // Reduce sensitivity after too many losses
                    if (predictionModel.sensitivity > 1) {
                        predictionModel.sensitivity--;
                        modelSensitivitySelect.value = predictionModel.sensitivity;
                        alert(`Model sensitivity reduced to ${getSensitivityName(predictionModel.sensitivity)}`);
                    }
                }
            }
        }

        function getSensitivityName(level) {
            switch(level) {
                case 1: return 'Low';
                case 2: return 'Medium';
                case 3: return 'High';
                default: return 'Medium';
            }
        }

        function enhancedMovingAverage(values, weight) {
            // Weighted average giving more importance to recent values
            if (values.length === 0) return 0;
            let sum = 0;
            let weightSum = 0;
            for (let i = 0; i < values.length; i++) {
                const w = Math.pow(weight, values.length - i);
                sum += values[i] * w;
                weightSum += w;
            }
            return sum / weightSum;
        }

        function calculateStandardDeviation(values) {
            if (values.length < 2) return 0;
            const avg = values.reduce((a,b) => a + b, 0) / values.length;
            return Math.sqrt(values.map(x => Math.pow(x - avg, 2)).reduce((a,b) => a + b) / values.length);
        }

        function detectRecentPatterns() {
            // Analyze last 5 spins for directional patterns
            if (spinHistory.length < 5) return 0;
            
            const lastFive = spinHistory.slice(-5);
            let cwCount = 0;
            let travelSum = 0;
            
            for (let i = 1; i < lastFive.length; i++) {
                if (lastFive[i-1].direction === 'cw') {
                    cwCount++;
                    const lastIndex = wheelLayout.indexOf(lastFive[i-1].number);
                    const currentIndex = wheelLayout.indexOf(lastFive[i].number);
                    travelSum += (lastIndex - currentIndex + wheelLayout.length) % wheelLayout.length;
                }
            }
            
            const cwRatio = cwCount / (lastFive.length - 1);
            const avgTravel = travelSum / Math.max(1, cwCount);
            
            // If strong directional tendency, suggest adjustment
            if (cwRatio > 0.75) return avgTravel > 18 ? 1 : -1;
            if (cwRatio < 0.25) return avgTravel > 18 ? -1 : 1;
            return 0;
        }

        function checkSectorTendency(index) {
            // Check if numbers near this index are hitting more often
            const sectorSize = 5;
            const sectorStart = Math.floor(index / sectorSize) * sectorSize;
            let sectorHits = 0;
            
            const recentSpins = spinHistory.slice(-20); // Last 20 spins
            for (const spin of recentSpins) {
                const spinIndex = wheelLayout.indexOf(spin.number);
                if (Math.abs(spinIndex - index) <= sectorSize/2) {
                    sectorHits++;
                }
            }
            
            // If this sector is hot, don't adjust
            if (sectorHits > recentSpins.length * 0.3) return 0;
            
            // If cold sector, move prediction toward hotter sector
            return sectorHits < recentSpins.length * 0.1 ? 2 : 0;
        }

        function generatePrediction() {
            if (spinHistory.length < 5) { // Require more data points
                resetPrediction();
                return;
            }

            const sensitivity = predictionModel.sensitivity;
            const lastSpin = spinHistory[spinHistory.length - 1];
            const lastIndex = wheelLayout.indexOf(lastSpin.number);
            
            // 1. Dynamic Neighbor Count based on recent accuracy
            const baseNeighborCount = Math.max(3, 9 - Math.floor(predictionModel.consecutiveLosses/2));
            const neighborCount = Math.min(parseInt(neighborCountSelect.value) || baseNeighborCount;
            
            // 2. Enhanced Travel Analysis with standard deviation
            let predictedTravel, travelStdev;
            if (currentDirection === 'cw') {
                predictedTravel = enhancedMovingAverage(stats.cw.travelDistances, 0.5 + sensitivity*0.15);
                travelStdev = calculateStandardDeviation(stats.cw.travelDistances);
            } else {
                predictedTravel = enhancedMovingAverage(stats.ccw.travelDistances, 0.5 + sensitivity*0.15);
                travelStdev = calculateStandardDeviation(stats.ccw.travelDistances);
            }
            
            // 3. Volatility-Adaptive Prediction Range
            const volatilityFactor = Math.min(2, Math.max(0.5, travelStdev/8));
            const adjustedTravel = predictedTravel * (0.8 + sensitivity*0.1) * volatilityFactor;
            
            // 4. Recent Pattern Recognition
            const recentPatternAdjustment = detectRecentPatterns();
            const finalPredictedTravel = adjustedTravel * (1 + recentPatternAdjustment/20);
            
            // 5. Dynamic Position Prediction
            let predictedIndex;
            if (currentDirection === 'cw') {
                predictedIndex = (lastIndex - Math.round(finalPredictedTravel) + wheelLayout.length) % wheelLayout.length;
            } else {
                predictedIndex = (lastIndex + Math.round(finalPredictedTravel)) % wheelLayout.length;
            }
            
            // 6. Sector Analysis - Check if we're in a repeating sector
            const sectorBoost = checkSectorTendency(predictedIndex);
            if (sectorBoost > 0) {
                predictedIndex = (predictedIndex + sectorBoost) % wheelLayout.length;
            }
            
            const mainPrediction = wheelLayout[predictedIndex];
            
            // Get dynamic neighbors - wider spread when volatility is high
            const neighborSpread = Math.max(1, Math.min(9, Math.floor(3 + travelStdev/5)));
            const leftNeighbors = [];
            const rightNeighbors = [];
            
            for (let i = 1; i <= neighborCount; i++) {
                leftNeighbors.push(
                    wheelLayout[(predictedIndex - i*neighborSpread + wheelLayout.length) % wheelLayout.length]
                );
                rightNeighbors.push(
                    wheelLayout[(predictedIndex + i*neighborSpread) % wheelLayout.length]
                );
            }
            
            currentPrediction = mainPrediction;
            currentSelection = [mainPrediction, ...leftNeighbors, ...rightNeighbors];
            updatePredictionDisplay(mainPrediction, leftNeighbors, rightNeighbors);
        }

        function updatePredictionDisplay(mainNumber, leftNeighbors, rightNeighbors) {
            const neighborCount = leftNeighbors.length;
            const mainColor = getColorForNumber(mainNumber);
            
            predictedNumberDiv.textContent = mainNumber;
            predictedNumberDiv.style.color = mainColor === 'red' ? '#e74c3c' : 
                                          mainColor === 'black' ? '#2c3e50' : '#27ae60';
            
            // Update left neighbors (counter-clockwise)
            leftNeighborsDiv.innerHTML = '';
            document.getElementById('leftNeighborLabel').textContent = `Left ${neighborCount} (CCW)`;
            
            leftNeighbors.forEach(neighbor => {
                const neighborColor = getColorForNumber(neighbor);
                const neighborElement = document.createElement('div');
                neighborElement.className = 'neighbor';
                neighborElement.textContent = neighbor;
                neighborElement.style.backgroundColor = neighborColor === 'red' ? '#e74c3c' : 
                                                      neighborColor === 'black' ? '#2c3e50' : '#27ae60';
                leftNeighborsDiv.appendChild(neighborElement);
            });
            
            // Update right neighbors (clockwise)
            rightNeighborsDiv.innerHTML = '';
            document.getElementById('rightNeighborLabel').textContent = `Right ${neighborCount} (CW)`;
            
            rightNeighbors.forEach(neighbor => {
                const neighborColor = getColorForNumber(neighbor);
                const neighborElement = document.createElement('div');
                neighborElement.className = 'neighbor';
                neighborElement.textContent = neighbor;
                neighborElement.style.backgroundColor = neighborColor === 'red' ? '#e74c3c' : 
                                                      neighborColor === 'black' ? '#2c3e50' : '#27ae60';
                rightNeighborsDiv.appendChild(neighborElement);
            });
            
            updateSelectedNumbersDisplay();
        }

        function updateSelectedNumbersDisplay() {
            selectedNumbersDiv.innerHTML = '';
            
            const neighborCount = currentSelection.length > 1 ? 
                (currentSelection.length - 1) / 2 : 0;
                
            // Group numbers by their position relative to prediction
            const leftNumbers = currentSelection.slice(1, 1 + neighborCount).reverse(); // Left neighbors (counter-clockwise)
            const mainNumber = currentSelection[0];
            const rightNumbers = currentSelection.slice(1 + neighborCount); // Right neighbors (clockwise)
            
            // Display left neighbors
            leftNumbers.forEach(num => {
                addNumberToSelectionDisplay(num, 'left');
            });
            
            // Display main prediction
            addNumberToSelectionDisplay(mainNumber, 'main');
            
            // Display right neighbors
            rightNumbers.forEach(num => {
                addNumberToSelectionDisplay(num, 'right');
            });
        }

        function addNumberToSelectionDisplay(number, position) {
            const numElement = document.createElement('div');
            numElement.className = 'selected-number';
            numElement.textContent = number;
            
            // Color based on position
            if (position === 'main') {
                numElement.style.backgroundColor = getColorForNumber(number) === 'red' ? '#e74c3c' : 
                                                  getColorForNumber(number) === 'black' ? '#2c3e50' : '#27ae60';
                numElement.style.color = 'white';
            }
            
            // Check if this number was in the last spin
            if (spinHistory.length > 0) {
                const lastNumber = spinHistory[spinHistory.length - 1].number;
                if (number === lastNumber) {
                    numElement.classList.add('win');
                } else if (currentSelection.includes(lastNumber)) {
                    numElement.classList.add('loss');
                }
            }
            
            selectedNumbersDiv.appendChild(numElement);
        }

        function updateStats(number) {
            stats.total++;
            
            const wasWin = currentSelection.includes(number);
            const lastSpin = spinHistory[spinHistory.length - 1];
            
            if (wasWin) {
                if (lastSpin.direction === 'cw') {
                    stats.cw.wins++;
                } else {
                    stats.ccw.wins++;
                }
            }
        }

        function updateStatsDisplay() {
            totalSpinsSpan.textContent = stats.total;
            
            // CW stats
            cwWinsSpan.textContent = stats.cw.wins;
            const cwWinPct = stats.cw.total > 0 ? 
                Math.round((stats.cw.wins / stats.cw.total) * 100) : 0;
            cwWinPctSpan.textContent = `${cwWinPct}%`;
            
            const cwAvgTravel = stats.cw.travelDistances.length > 0 ?
                Math.round(stats.cw.travelDistances.reduce((a, b) => a + b, 0) / 
                          stats.cw.travelDistances.length) : 0;
            cwAvgTravelSpan.textContent = `${cwAvgTravel}`;
            
            // CCW stats
            ccwWinsSpan.textContent = stats.ccw.wins;
            const ccwWinPct = stats.ccw.total > 0 ? 
                Math.round((stats.ccw.wins / stats.ccw.total) * 100) : 0;
            ccwWinPctSpan.textContent = `${ccwWinPct}%`;
            
            const ccwAvgTravel = stats.ccw.travelDistances.length > 0 ?
                Math.round(stats.ccw.travelDistances.reduce((a, b) => a + b, 0) / 
                          stats.ccw.travelDistances.length) : 0;
            ccwAvgTravelSpan.textContent = `${ccwAvgTravel}`;
        }

        function updateSectorStats() {
            sectorStatsDiv.innerHTML = '';
            
            stats.sectorPerformance.forEach((sector, index) => {
                const sectorElement = document.createElement('div');
                sectorElement.className = 'sector';
                
                const hitRate = sector.appearances > 0 ? 
                    Math.round((sector.hits / sector.appearances) * 100) : 0;
                
                if (sector.appearances > 0) {
                    if (hitRate > 30) {
                        sectorElement.classList.add('hot-sector');
                    } else if (hitRate < 15) {
                        sectorElement.classList.add('cold-sector');
                    }
                }
                
                const numbersInSector = wheelLayout.slice(index*5, (index+1)*5);
                sectorElement.innerHTML = `
                    <div>Sector ${index+1}</div>
                    <div>${numbersInSector.join(', ')}</div>
                    <div>${hitRate}% hit rate</div>
                `;
                
                sectorStatsDiv.appendChild(sectorElement);
            });
        }

        function updateModelDisplay() {
            const accuracy = predictionModel.totalPredictions > 0 ?
                Math.round((predictionModel.correctPredictions / predictionModel.totalPredictions) * 100) : 0;
            modelAccuracySpan.textContent = `${accuracy}%`;
            modelStreakSpan.textContent = predictionModel.currentStreak;
            modelConsecutiveLossesSpan.textContent = predictionModel.consecutiveLosses;
        }

        function updateTravelPatternsDisplay() {
            travelPatternsDiv.innerHTML = `
                <div class="pattern-row">
                    <span>Direction</span>
                    <span>From</span>
                    <span>To</span>
                    <span>Pockets</span>
                </div>
            `;
            
            stats.travelPatterns.slice(0, 5).forEach(pattern => {
                const row = document.createElement('div');
                row.className = 'pattern-row';
                row.innerHTML = `
                    <span>${pattern.direction.toUpperCase()}</span>
                    <span>${pattern.from}</span>
                    <span>${pattern.to}</span>
                    <span>${pattern.distance}</span>
                `;
                travelPatternsDiv.appendChild(row);
            });
        }

        function updateWheelDisplay() {
            // Clear previous markers
            const oldMarkers = document.querySelectorAll('.wheel-marker, .wheel-prediction-range');
            oldMarkers.forEach(marker => marker.remove());
            
            if (spinHistory.length === 0) return;
            
            // Show last spin
            const lastSpin = spinHistory[spinHistory.length - 1];
            const lastIndex = wheelLayout.indexOf(lastSpin.number);
            const angleIncrement = (2 * Math.PI) / wheelLayout.length;
            const lastAngle = lastIndex * angleIncrement - Math.PI / 2;
            
            const lastX = 150 + 140 * Math.cos(lastAngle);
            const lastY = 150 + 140 * Math.sin(lastAngle);
            
            const lastMarker = document.createElement('div');
            lastMarker.className = 'wheel-marker';
            lastMarker.style.backgroundColor = 'gold';
            lastMarker.style.left = `${lastX}px`;
            lastMarker.style.top = `${lastY}px`;
            lastMarker.title = `Last: ${lastSpin.number} (${lastSpin.direction.toUpperCase()})`;
            rouletteWheel.appendChild(lastMarker);
            
            // Show prediction if available
            if (currentPrediction) {
                const predIndex = wheelLayout.indexOf(currentPrediction);
                const predAngle = predIndex * angleIncrement - Math.PI / 2;
                const predX = 150 + 140 * Math.cos(predAngle);
                const predY = 150 + 140 * Math.sin(predAngle);
                
                const predMarker = document.createElement('div');
                predMarker.className = 'wheel-marker';
                predMarker.style.backgroundColor = 'red';
                predMarker.style.left = `${predX}px`;
                predMarker.style.top = `${predY}px`;
                predMarker.title = `Predicted: ${currentPrediction} (${currentDirection.toUpperCase()})`;
                rouletteWheel.appendChild(predMarker);
            }
            
            // Add hot/cold number visualization
            const recentSpins = spinHistory.slice(-30); // Last 30 spins
            const numberCounts = {};
            
            recentSpins.forEach(spin => {
                numberCounts[spin.number] = (numberCounts[spin.number] || 0) + 1;
            });
            
            document.querySelectorAll('.wheel-number').forEach(el => {
                const num = parseInt(el.textContent);
                const count = numberCounts[num] || 0;
                if (count > 0) {
                    const intensity = Math.min(1, count/5); // Max 5 appearances
                    el.style.boxShadow = `0 0 ${5 + intensity*10}px ${intensity > 0.5 ? 'gold' : 'orange'}`;
                    el.title = `Number ${num}: Hit ${count} times in last 30 spins`;
                } else {
                    el.style.boxShadow = 'none';
                    el.title = `Number ${num}`;
                }
            });
        }

        function updateHistoryDisplay() {
            historyListDiv.innerHTML = '';
            // Show history in reverse order (newest first)
            const reversedHistory = [...spinHistory].reverse();
            reversedHistory.forEach((spin, index) => {
                const spinElement = document.createElement('div');
                spinElement.className = `history-item ${spin.color}`;
                spinElement.textContent = spin.number;
                spinElement.title = `Spin ${spinHistory.length - index}: ${spin.number} ${spin.color} (${spin.direction.toUpperCase()})`;
                historyListDiv.appendChild(spinElement);
            });
            
            historyCountSpan.textContent = `${spinHistory.length} spins recorded`;
        }

        function resetPrediction() {
            currentPrediction = null;
            currentSelection = [];
            
            predictedNumberDiv.textContent = '-';
            leftNeighborsDiv.innerHTML = '';
            rightNeighborsDiv.innerHTML = '';
            
            selectedNumbersDiv.innerHTML = '<div>No active prediction</div>';
        }

        function clearHistory() {
            if (confirm('Are you sure you want to clear all history?')) {
                spinHistory = [];
                currentDirection = 'cw';
                stats = {
                    total: 0,
                    cw: {
                        wins: 0,
                        total: 0,
                        travelDistances: []
                    },
                    ccw: {
                        wins: 0,
                        total: 0,
                        travelDistances: []
                    },
                    travelPatterns: [],
                    sectorPerformance: Array(8).fill(0).map(() => ({ hits: 0, appearances: 0 })),
                    lastTenDirections: []
                };
                resetMartingale();
                resetModel();
                resetPrediction();
                updateHistoryDisplay();
                updateStatsDisplay();
                updateTravelPatternsDisplay();
                updateWheelDisplay();
                updateSectorStats();
                saveToLocalStorage();
            }
        }

        function exportHistory() {
            if (spinHistory.length === 0) {
                alert('No history to export');
                return;
            }
            
            const csvContent = "data:text/csv;charset=utf-8," +
                ["Number,Color,Direction,Timestamp"]
                .concat(spinHistory.map(spin => 
                    `${spin.number},${spin.color},${spin.direction},${spin.timestamp}`
                )).join("\n");
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "roulette_history.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportMartingaleData() {
            if (martingaleTransactions.length === 0) {
                alert('No Martingale data to export');
                return;
            }
            
            const headers = [
                'Timestamp', 'Spin Number', 'Result', 'Landed Number', 
                'Numbers Bet', 'Bet Per Number', 'Total Bet', 'Payout',
                'Profit/Loss', 'Streak', 'Bankroll After', 'Direction'
            ];
            
            const csvRows = [
                headers.join(','), // header row first
                ...martingaleTransactions.map(t => [
                    t.timestamp,
                    t.spinNumber,
                    t.result,
                    t.numberLanded,
                    `"${t.numbersBet}"`, // wrap in quotes in case numbers contain commas
                    t.betPerNumber.toFixed(2),
                    t.totalBet.toFixed(2),
                    t.payout.toFixed(2),
                    t.profitLoss.toFixed(2),
                    t.currentStreak,
                    t.bankrollAfter.toFixed(2),
                    t.direction.toUpperCase()
                ].join(','))
            ];
            
            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `martingale_data_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function getColorForNumber(number) {
            // 0 is green
            if (number === 0) return 'green';
            
            // Red numbers
            return redNumbers.includes(number) ? 'red' : 'black';
        }
        
        function saveToLocalStorage() {
            const data = {
                spinHistory,
                stats,
                martingale,
                martingaleTransactions,
                predictionModel,
                currentDirection,
                currentPrediction,
                currentSelection,
                neighborCount: parseInt(neighborCountSelect.value) || 9,
                modelSensitivity: parseInt(modelSensitivitySelect.value) || 2,
                maxConsecutiveLosses: parseInt(maxConsecutiveLossesInput.value) || 6
            };
            localStorage.setItem('rouletteAnalystData', JSON.stringify(data));
        }
        
        function loadFromLocalStorage() {
            const savedData = localStorage.getItem('rouletteAnalystData');
            if (savedData) {
                const data = JSON.parse(savedData);
                spinHistory = data.spinHistory || [];
                stats = data.stats || {
                    total: 0,
                    cw: { wins: 0, total: 0, travelDistances: [] },
                    ccw: { wins: 0, total: 0, travelDistances: [] },
                    travelPatterns: [],
                    sectorPerformance: Array(8).fill(0).map(() => ({ hits: 0, appearances: 0 })),
                    lastTenDirections: []
                };
                martingale = data.martingale || {
                    baseBet: 1,
                    currentBet: 1,
                    bankroll: 100,
                    totalProfitLoss: 0,
                    currentStreak: 0,
                    longestStreak: 0,
                    betsWon: 0,
                    betsLost: 0,
                    maxLosses: 6,
                    active: false
                };
                martingaleTransactions = data.martingaleTransactions || [];
                predictionModel = data.predictionModel || {
                    sensitivity: 2,
                    maxConsecutiveLosses: 6,
                    consecutiveLosses: 0,
                    currentStreak: 0,
                    totalPredictions: 0,
                    correctPredictions: 0,
                    cwAvgTravel: 0,
                    ccwAvgTravel: 0,
                    cwTravelCount: 0,
                    ccwTravelCount: 0
                };
                currentDirection = data.currentDirection || 'cw';
                currentPrediction = data.currentPrediction || null;
                currentSelection = data.currentSelection || [];
                
                // Update UI
                updateHistoryDisplay();
                updateStatsDisplay();
                updateMartingaleDisplay();
                updateModelDisplay();
                updateWheelDisplay();
                updateTravelPatternsDisplay();
                updateSectorStats();
                
                // Set neighbor count
                if (data.neighborCount) {
                    neighborCountSelect.value = data.neighborCount;
                }
                
                // Set model settings
                if (data.modelSensitivity) {
                    modelSensitivitySelect.value = data.modelSensitivity;
                    predictionModel.sensitivity = data.modelSensitivity;
                }
                if (data.maxConsecutiveLosses) {
                    maxConsecutiveLossesInput.value = data.maxConsecutiveLosses;
                    predictionModel.maxConsecutiveLosses = data.maxConsecutiveLosses;
                }
                
                if (currentPrediction) {
                    const neighborCount = parseInt(neighborCountSelect.value) || 9;
                    const mainNumber = currentPrediction;
                    const mainIndex = wheelLayout.indexOf(mainNumber);
                    const leftNeighbors = [];
                    const rightNeighbors = [];
                    
                    for (let i = 1; i <= neighborCount; i++) {
                        leftNeighbors.push(
                            wheelLayout[(mainIndex - i + wheelLayout.length) % wheelLayout.length]
                        );
                        rightNeighbors.push(
                            wheelLayout[(mainIndex + i) % wheelLayout.length]
                        );
                    }
                    
                    updatePredictionDisplay(mainNumber, leftNeighbors, rightNeighbors);
                }
                
                // Update inputs to match loaded values
                baseBetInput.value = martingale.baseBet;
                bankrollInput.value = martingale.bankroll;
                maxLossesInput.value = martingale.maxLosses;
            }
        }

        function updateMartingaleStats(number) {
            const wasWin = currentSelection.includes(number);
            const numberCount = currentSelection.length;
            
            // Calculate total bet amount (bet per number * number of numbers)
            const totalBetAmount = martingale.currentBet * numberCount;
            
            // Record transaction before updating values
            const transaction = {
                timestamp: new Date().toISOString(),
                spinNumber: spinHistory.length,
                result: wasWin ? 'WIN' : 'LOSS',
                numberLanded: number,
                numbersBet: currentSelection.join(', '),
                betPerNumber: martingale.currentBet,
                totalBet: totalBetAmount,
                payout: wasWin ? (36 * martingale.currentBet) : 0,
                profitLoss: wasWin ? (36 * martingale.currentBet - totalBetAmount) : -totalBetAmount,
                currentStreak: martingale.currentStreak + (wasWin ? 0 : 1),
                bankrollAfter: wasWin ? 
                    martingale.bankroll + (36 * martingale.currentBet - totalBetAmount) : 
                    martingale.bankroll - totalBetAmount,
                direction: currentDirection
            };
            
            if (wasWin) {
                // Win - we get 36 units for each winning number (minus the bet)
                const winAmount = 36 * martingale.currentBet - totalBetAmount;
                martingale.bankroll += winAmount;
                martingale.totalProfitLoss += winAmount;
                
                // Update longest streak before resetting current streak
                if (martingale.currentStreak > martingale.longestStreak) {
                    martingale.longestStreak = martingale.currentStreak;
                }
                
                martingale.currentStreak = 0;
                martingale.currentBet = martingale.baseBet; // Reset to base bet
                martingale.betsWon++;
            } else {
                // Loss - we lose the total bet amount
                martingale.bankroll -= totalBetAmount;
                martingale.totalProfitLoss -= totalBetAmount;
                martingale.currentStreak++;
                martingale.betsLost++;
                
                // Update longest streak if current streak exceeds it
                if (martingale.currentStreak > martingale.longestStreak) {
                    martingale.longestStreak = martingale.currentStreak;
                }
                
                // Check if we've hit max losses
                if (martingale.currentStreak >= martingale.maxLosses) {
                    alert(`Max losses (${martingale.maxLosses}) reached! Resetting to base bet.`);
                    martingale.currentBet = martingale.baseBet;
                    martingale.currentStreak = 0; // Reset current streak but keep longestStreak
                } else {
                    martingale.currentBet *= 2; // Double the bet for next time
                }
            }
            
            // Check if bankroll is insufficient for next bet
            if (martingale.bankroll < (martingale.currentBet * numberCount)) {
                alert(`Bankroll insufficient for next bet! Need ${martingale.currentBet * numberCount} but only have ${martingale.bankroll}. Resetting to base bet.`);
                martingale.currentBet = martingale.baseBet;
                martingale.currentStreak = 0;
            }
            
            // Add transaction to history after updating all values
            martingaleTransactions.push(transaction);
        }

        function updateMartingaleSettings() {
            martingale.baseBet = Math.max(0.5, parseFloat(baseBetInput.value) || 1);
            martingale.bankroll = parseFloat(bankrollInput.value) || 100;
            martingale.maxLosses = Math.min(8, parseInt(maxLossesInput.value) || 6);
            martingale.currentBet = martingale.baseBet;
            
            // Dynamic bet sizing based on bankroll percentage
            martingale.baseBet = Math.max(0.5, martingale.bankroll * 0.01); // 1% of bankroll
            baseBetInput.value = martingale.baseBet.toFixed(2);
            
            updateMartingaleDisplay();
            saveToLocalStorage();
        }

        function updateModelSettings() {
            predictionModel.sensitivity = parseInt(modelSensitivitySelect.value) || 2;
            predictionModel.maxConsecutiveLosses = parseInt(maxConsecutiveLossesInput.value) || 6;
            updateModelDisplay();
            saveToLocalStorage();
        }

        function resetMartingale() {
            martingale = {
                baseBet: Math.max(0.5, parseFloat(baseBetInput.value) || 1),
                currentBet: Math.max(0.5, parseFloat(baseBetInput.value) || 1),
                bankroll: parseFloat(bankrollInput.value) || 100,
                totalProfitLoss: 0,
                currentStreak: 0,
                longestStreak: 0,
                betsWon: 0,
                betsLost: 0,
                maxLosses: Math.min(8, parseInt(maxLossesInput.value) || 6),
                active: false
            };
            martingaleTransactions = [];
            updateMartingaleDisplay();
            saveToLocalStorage();
        }

        function resetModel() {
            predictionModel = {
                sensitivity: parseInt(modelSensitivitySelect.value) || 2,
                maxConsecutiveLosses: parseInt(maxConsecutiveLossesInput.value) || 6,
                consecutiveLosses: 0,
                currentStreak: 0,
                totalPredictions: 0,
                correctPredictions: 0,
                cwAvgTravel: 0,
                ccwAvgTravel: 0,
                cwTravelCount: 0,
                ccwTravelCount: 0
            };
            updateModelDisplay();
            saveToLocalStorage();
        }

        function updateMartingaleDisplay() {
            currentBetSpan.textContent = martingale.currentBet.toFixed(2);
            currentBankrollSpan.textContent = martingale.bankroll.toFixed(2);
            
            // Style profit/loss
            totalProfitLossSpan.textContent = Math.abs(martingale.totalProfitLoss).toFixed(2);
            if (martingale.totalProfitLoss >= 0) {
                totalProfitLossSpan.className = 'profit';
                totalProfitLossSpan.textContent = '+' + totalProfitLossSpan.textContent;
            } else {
                totalProfitLossSpan.className = 'loss';
                totalProfitLossSpan.textContent = '-' + totalProfitLossSpan.textContent;
            }
            
            currentStreakSpan.textContent = martingale.currentStreak;
            longestStreakSpan.textContent = martingale.longestStreak;
            betsWonSpan.textContent = martingale.betsWon;
            betsLostSpan.textContent = martingale.betsLost;
        }
    </script>
</body>
</html>
