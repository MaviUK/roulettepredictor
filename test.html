<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Roulette Predictor</title>
    <style>
        /* [Previous CSS styles remain the same] */
        .strategy {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .best {
            background: #e6f7ff;
            border-left: 4px solid #1890ff;
        }
    </style>
</head>
<body>
    <!-- [Previous HTML structure remains the same until <script>] -->

    <script>
        // Enhanced prediction strategies
        const STRATEGIES = {
            MEAN_CW: { name: "Mean CW", dir: 'cw' },
            MEAN_CCW: { name: "Mean CCW", dir: 'ccw' },
            ALTERNATING: { name: "Alternating", dir: null },
            RECENT_BIAS: { name: "Recent Bias", dir: null }
        };

        // Enhanced game state
        let strategies = {
            current: STRATEGIES.MEAN_CW,
            lastDirection: 'cw',
            performance: Object.keys(STRATEGIES).reduce((acc, key) => {
                acc[key] = { wins: 0, losses: 0, currentStreak: 0, longestStreak: 0 };
                return acc;
            }, {})
        };

        // Modified makeNextPrediction function
        function makeNextPrediction() {
            if (numbers.length < 2) {
                currentPrediction = null;
                return;
            }

            // Calculate all possible predictions
            const { meanCW, meanCCW } = calculateMeanSteps();
            const lastNum = numbers[numbers.length-1];
            const prevNum = numbers[numbers.length-2];
            
            // Determine natural direction
            const naturalDirection = getDirection(prevNum, lastNum);
            
            // Generate predictions for all strategies
            const allPredictions = {};
            
            // 1. Mean CW prediction
            allPredictions.MEAN_CW = {
                ...predictWithDirection(lastNum, 'cw', meanCW, meanCCW),
                strategy: STRATEGIES.MEAN_CW
            };
            
            // 2. Mean CCW prediction
            allPredictions.MEAN_CCW = {
                ...predictWithDirection(lastNum, 'ccw', meanCW, meanCCW),
                strategy: STRATEGIES.MEAN_CCW
            };
            
            // 3. Alternating direction prediction
            const altDirection = strategies.lastDirection === 'cw' ? 'ccw' : 'cw';
            allPredictions.ALTERNATING = {
                ...predictWithDirection(lastNum, altDirection, meanCW, meanCCW),
                strategy: STRATEGIES.ALTERNATING
            };
            strategies.lastDirection = altDirection;
            
            // 4. Recent bias prediction (uses direction of last 3 spins)
            const recentDirection = getRecentBiasDirection();
            allPredictions.RECENT_BIAS = {
                ...predictWithDirection(lastNum, recentDirection, meanCW, meanCCW),
                strategy: STRATEGIES.RECENT_BIAS
            };
            
            // Select best prediction based on performance
            currentPrediction = selectBestPrediction(allPredictions);
            predictions.push(currentPrediction);
        }

        function predictWithDirection(lastNumber, direction, meanCW, meanCCW) {
            const predictedNumber = predictNext(lastNumber, direction, meanCW, meanCCW);
            const neighbors = getNeighbors(predictedNumber);
            
            return {
                predictedFor: lastNumber,
                predicted: predictedNumber,
                neighbors,
                actual: null,
                isCorrect: null,
                strategy: null
            };
        }

        function getRecentBiasDirection() {
            if (numbers.length < 4) return 'cw';
            
            let cwCount = 0;
            for (let i = numbers.length-3; i < numbers.length-1; i++) {
                const dir = getDirection(numbers[i], numbers[i+1]);
                if (dir === 'cw') cwCount++;
            }
            
            return cwCount >= 2 ? 'cw' : 'ccw';
        }

        function selectBestPrediction(allPredictions) {
            // Simple selection - could be enhanced with more sophisticated logic
            // Currently selects strategy with best win rate
            let bestKey = 'MEAN_CW';
            let bestPerformance = strategies.performance[bestKey].wins / 
                                (strategies.performance[bestKey].wins + strategies.performance[bestKey].losses) || 0;
            
            for (const [key, prediction] of Object.entries(allPredictions)) {
                const perf = strategies.performance[key];
                const winRate = perf.wins / (perf.wins + perf.losses) || 0;
                
                if (winRate > bestPerformance) {
                    bestPerformance = winRate;
                    bestKey = key;
                }
            }
            
            return { ...allPredictions[bestKey], selectedStrategy: bestKey };
        }

        // Modified checkPrediction function
        function checkPrediction(actualNumber) {
            const lastPrediction = predictions[predictions.length-1];
            const isCorrect = lastPrediction.neighbors.includes(actualNumber);
            const strategyKey = lastPrediction.selectedStrategy;
            
            // Update strategy performance
            const strategyPerf = strategies.performance[strategyKey];
            if (isCorrect) {
                strategyPerf.wins++;
                strategyPerf.currentStreak = 0;
            } else {
                strategyPerf.losses++;
                strategyPerf.currentStreak++;
                if (strategyPerf.currentStreak > strategyPerf.longestStreak) {
                    strategyPerf.longestStreak = strategyPerf.currentStreak;
                }
            }
            
            // Update global streak
            if (!isCorrect) {
                lossStreak++;
                if (lossStreak > longestLossStreak) {
                    longestLossStreak = lossStreak;
                }
            } else {
                lossStreak = 0;
            }
            
            lastPrediction.actual = actualNumber;
            lastPrediction.isCorrect = isCorrect;
            lastPrediction.streak = lossStreak;
        }

        // Enhanced display functions
        function updateDisplay() {
            // ... [previous updateDisplay code] ...
            
            // Add strategy information
            predictionDiv.innerHTML += `
                <div class="strategy ${currentPrediction.selectedStrategy === 'BEST' ? 'best' : ''}">
                    <strong>Strategy:</strong> ${currentPrediction.strategy.name}
                </div>
                <div class="strategies">
                    <h3>Strategy Performance</h3>
                    ${Object.entries(strategies.performance).map(([key, perf]) => `
                        <div class="strategy ${key === currentPrediction.selectedStrategy ? 'best' : ''}">
                            <strong>${STRATEGIES[key].name}:</strong>
                            ${perf.wins}W/${perf.losses}L (${perf.longestStreak} max loss)
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // [Rest of the code remains the same]
    </script>
</body>
</html>
