<script>
  const europeanWheel = [
    0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23,
    10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26
  ];

  let spins = [];
  let lossStreak = { CW: 0, CCW: 0, total: 0 };
  let maxLoss = { CW: 0, CCW: 0, total: 0 };

  function getIndex(number) {
    return europeanWheel.indexOf(number);
  }

  function calculatePockets(from, to, direction) {
    const fromIndex = getIndex(from);
    const toIndex = getIndex(to);
    return direction === "CW"
      ? (toIndex - fromIndex + europeanWheel.length) % europeanWheel.length
      : (fromIndex - toIndex + europeanWheel.length) % europeanWheel.length;
  }

  function getNeighbors(number) {
    const idx = getIndex(number);
    let neighbors = [];
    for (let i = -9; i <= 9; i++) {
      neighbors.push(europeanWheel[(idx + i + europeanWheel.length) % europeanWheel.length]);
    }
    return neighbors;
  }

  function predictNext(history) {
    if (history.length < 5) return null;
    const lastSpin = history[history.length - 1];
    const dir = lastSpin.direction === "CW" ? "CCW" : "CW";
    const relevant = history.filter(s => s.direction === dir).slice(-5);
    if (relevant.length < 5) return null;

    const pocketsList = relevant.map(s => s.pockets).sort((a, b) => a - b).slice(1, 4);
    const avgPockets = Math.round(pocketsList.reduce((a, b) => a + b, 0) / 3);

    const fromIndex = getIndex(lastSpin.to);
    const newIndex = dir === "CW"
      ? (fromIndex + avgPockets) % europeanWheel.length
      : (fromIndex - avgPockets + europeanWheel.length) % europeanWheel.length;

    return europeanWheel[newIndex];
  }

  function updateStats(newSpin, to) {
    const previousPrediction = predictNext(spins);
    const predictionNeighbors = previousPrediction ? getNeighbors(previousPrediction) : [];
    const correct = predictionNeighbors.includes(to);

    if (!correct) {
      lossStreak[newSpin.direction]++;
      lossStreak.total++;
      maxLoss.CW = Math.max(maxLoss.CW, lossStreak.CW);
      maxLoss.CCW = Math.max(maxLoss.CCW, lossStreak.CCW);
      maxLoss.total = Math.max(maxLoss.total, lossStreak.total);
    } else {
      lossStreak[newSpin.direction] = 0;
      lossStreak.total = 0;
    }

    spins.push(newSpin);
    const prediction = predictNext(spins);
    const neighborText = prediction ? getNeighbors(prediction).join(", ") : "";

    document.getElementById('prediction').innerHTML = `Next predicted number: <strong>${prediction ?? "Not enough data yet"}</strong>`;
    document.getElementById('neighbors').innerHTML = prediction ? `Neighbors (±9): <strong>${neighborText}</strong>` : "";

    const cwSpins = spins.filter(s => s.direction === "CW").slice(-5).reverse().map(spin =>
      `<p>From: ${spin.from} → To: ${spin.to} | Pockets: ${spin.pockets}</p>`).join('');
    const ccwSpins = spins.filter(s => s.direction === "CCW").slice(-5).reverse().map(spin =>
      `<p>From: ${spin.from} → To: ${spin.to} | Pockets: ${spin.pockets}</p>`).join('');

    document.getElementById('cwHistory').innerHTML = cwSpins;
    document.getElementById('ccwHistory').innerHTML = ccwSpins;
    document.getElementById('cwStreak').textContent = maxLoss.CW;
    document.getElementById('ccwStreak').textContent = maxLoss.CCW;
    document.getElementById('totalStreak').textContent = maxLoss.total;
  }

  function addSimpleSpin() {
    const toInput = document.getElementById('singleTo');
    const to = Number(toInput.value);
    if (isNaN(to)) return alert("Please enter a valid number.");
    const direction = document.getElementById('direction').value;
    const from = spins.length ? spins[spins.length - 1].to : to;
    const pockets = calculatePockets(from, to, direction);
    const newSpin = { from, to, direction, pockets };
    updateStats(newSpin, to);
    toInput.value = '';
  }

  function addBatchSpins() {
    const inputBox = document.getElementById('batchInput');
    const input = inputBox.value;
    const numbers = input.split(/[^0-9]+/).map(n => parseInt(n)).filter(n => !isNaN(n));
    if (numbers.length < 2) return alert("Need at least 2 numbers.");

    let direction = document.getElementById('direction').value;
    for (let i = 1; i < numbers.length; i++) {
      const from = numbers[i - 1];
      const to = numbers[i];
      const pockets = calculatePockets(from, to, direction);
      const newSpin = { from, to, direction, pockets };
      updateStats(newSpin, to);
      direction = direction === "CW" ? "CCW" : "CW";
    }
    inputBox.value = '';
  }

  function resetAll() {
    spins = [];
    lossStreak = { CW: 0, CCW: 0, total: 0 };
    maxLoss = { CW: 0, CCW: 0, total: 0 };
    document.getElementById('prediction').innerHTML = 'Next predicted number: <strong>Not enough data yet</strong>';
    document.getElementById('neighbors').innerHTML = '';
    document.getElementById('cwHistory').innerHTML = '';
    document.getElementById('ccwHistory').innerHTML = '';
    document.getElementById('cwStreak').textContent = '0';
    document.getElementById('ccwStreak').textContent = '0';
    document.getElementById('totalStreak').textContent = '0';
    document.getElementById('batchInput').value = '';
    document.getElementById('singleTo').value = '';
  }

  function exportResults() {
    if (spins.length === 0) return alert("No spins to export.");

    const rows = [["Predicted Number", "Landed Number", "Pockets", "Result", "Losing Streak"]];

    for (let i = 1; i < spins.length; i++) {
      const historySoFar = spins.slice(0, i);
      const prediction = predictNext(historySoFar);
      const predictionNeighbors = prediction ? getNeighbors(prediction) : [];
      const landed = spins[i].to;
      const result = predictionNeighbors.includes(landed) ? "Win" : "Lose";
      const lossCount = rows.filter(r => r[3] === "Lose").length - rows.filter(r => r[3] === "Win").length;
      rows.push([prediction ?? "N/A", landed, spins[i].pockets, result, result === "Win" ? 0 : lossCount]);
    }

    let csvContent = "data:text/csv;charset=utf-8," + rows.map(e => e.join(",")).join("\n");
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "roulette_predictions.csv");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
</script>
