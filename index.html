// ---------- SIMPLE STEP-FREQUENCY PREDICTION MODEL ----------

const WINDOW_STEPS = 35;        // number of most recent steps to inspect
const THRESHOLD_COUNT = 6;      // dominant step must appear at least this many times
const MIN_STEPS_FOR_MODEL = WINDOW_STEPS;

function simplePrediction(spins) {
  if (spins.length < 2) {
    return { shouldBet: false, reason: "Need at least 2 spins", debug: null };
  }

  const stepsAll = buildSteps(spins);
  if (stepsAll.length < MIN_STEPS_FOR_MODEL) {
    return {
      shouldBet: false,
      reason: `Need at least ${MIN_STEPS_FOR_MODEL + 1} spins for the model`,
      debug: null
    };
  }

  // Take last WINDOW_STEPS steps
  const windowSteps = stepsAll.slice(-WINDOW_STEPS);

  // Count frequencies
  const counts = new Map();
  for (const s of windowSteps) {
    counts.set(s, (counts.get(s) || 0) + 1);
  }

  // Find dominant step
  let bestStep = null;
  let bestCount = 0;
  for (const [s, c] of counts.entries()) {
    if (c > bestCount) {
      bestCount = c;
      bestStep = s;
    }
  }

  if (bestStep === null || bestCount < THRESHOLD_COUNT) {
    return {
      shouldBet: false,
      reason: `No strong step pattern yet (top step appears ${bestCount}×, need ${THRESHOLD_COUNT}×)`,
      debug: { bestStep, bestCount }
    };
  }

  // Build bet: move last number by bestStep on the wheel
  const lastNum = spins[spins.length - 1];
  const idxLast = INDEX_OF[lastNum];
  if (idxLast === undefined) {
    return { shouldBet: false, reason: "Last number not on wheel", debug: null };
  }

  const centreIdx = (idxLast + bestStep) % 37;
  const centreNum = WHEEL_ORDER[centreIdx];
  const neighbours = neighboursForCentre(centreNum);

  return {
    shouldBet: true,
    centreNum,
    neighbours,
    dominantStep: bestStep,
    count: bestCount,
    reason: `Step ${bestStep} appears ${bestCount}× in last ${WINDOW_STEPS} spins`
  };
}
