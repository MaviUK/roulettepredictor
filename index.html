<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Roulette Step Predictor</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #0b1020;
      color: #f5f5f5;
    }
    h1, h2, h3 {
      margin-top: 0;
      font-weight: 700;
    }
    h1 { font-size: 1.8rem; }
    h2 { font-size: 1.3rem; margin-top: 1.5rem; }
    h3 { font-size: 1.1rem; margin-top: 1rem; }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 3fr);
      gap: 1.5rem;
    }

    @media (max-width: 900px) {
      .container {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: #151a2c;
      border-radius: 14px;
      padding: 1.1rem 1.25rem;
      box-shadow: 0 14px 40px rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.04);
    }

    label { display: block; margin-bottom: 0.35rem; font-size: 0.9rem; opacity: 0.9; }
    input[type="number"], textarea {
      width: 100%;
      padding: 0.6rem 0.7rem;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: #0b1020;
      color: #f5f5f5;
      font-size: 0.95rem;
      outline: none;
    }
    input[type="number"]:focus, textarea:focus {
      border-color: #58d5ff;
      box-shadow: 0 0 0 1px rgba(88,213,255,0.3);
    }
    textarea {
      min-height: 150px;
      resize: vertical;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.55rem 0.9rem;
      border-radius: 999px;
      border: 0;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      margin-right: 0.5rem;
      margin-top: 0.4rem;
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.15s ease;
    }
    .btn-primary {
      background: #ff3366;
      color: #fff;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.05),0 10px 25px rgba(255,51,102,0.4);
    }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 14px 30px rgba(255,51,102,0.5); }
    .btn-secondary {
      background: #232b49;
      color: #f5f5f5;
    }
    .btn-secondary:hover {
      background: #2f385c;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .pill-good { background: rgba(0,200,140,0.15); color: #4cf3b6; }
    .pill-bad  { background: rgba(255,120,80,0.15); color: #ffb899; }
    .pill-neutral { background: rgba(130,150,255,0.15); color: #b3bfff; }

    .section {
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(255,255,255,0.06);
    }

    .list-inline {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem 0.4rem;
      margin: 0.25rem 0;
      padding: 0;
      list-style: none;
      font-size: 0.9rem;
    }
    .list-inline li {
      padding: 0.17rem 0.5rem;
      border-radius: 999px;
      background: rgba(255,255,255,0.05);
    }

    .mono { font-family: "SF Mono", Menlo, Consolas, monospace; font-size: 0.85rem; }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.6rem;
      margin-top: 0.4rem;
    }
    @media (max-width: 600px) {
      .stat-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    .stat {
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      padding: 0.5rem 0.6rem;
      font-size: 0.8rem;
    }
    .stat span {
      display: block;
    }
    .stat-label {
      opacity: 0.7;
      margin-bottom: 0.1rem;
    }
    .stat-value {
      font-weight: 700;
      font-size: 0.95rem;
    }

    .small {
      font-size: 0.8rem;
      opacity: 0.8;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      margin-top: 0.2rem;
    }
    .chip {
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: rgba(255,255,255,0.07);
      font-size: 0.8rem;
    }
  </style>
</head>
<body>

  <h1>Roulette Hybrid Step Predictor</h1>
  <p class="small">
    Enter each spin result and the model will decide <strong>BET / NO BET</strong> for the next spin and,
    if betting, which <strong>centre number + 8 neighbours each side</strong> to cover.
    You can also paste a long history to <strong>simulate</strong> how the model would have performed.
  </p>

  <div class="container">
    <!-- LIVE INPUT / OUTPUT -->
    <div class="card">
      <h2>Live Mode</h2>

      <label for="spinInput">Enter latest spin (0–36), then click "Add Spin"</label>
      <input type="number" id="spinInput" min="0" max="36" placeholder="e.g. 23" />
      <div>
        <button class="btn btn-primary" id="addSpinBtn">Add Spin</button>
        <button class="btn btn-secondary" id="resetSpinsBtn">Reset History</button>
      </div>

      <div class="section">
        <h3>Current History</h3>
        <div class="small" id="historyInfo">No spins yet.</div>
        <ul class="list-inline mono" id="historyList"></ul>
      </div>

      <div class="section">
        <h3>Next Spin Recommendation</h3>
        <div id="recommendation">
          <span class="pill pill-neutral">No Data</span>
          <p class="small">Enter at least 3–4 spins to get started.</p>
        </div>
      </div>

      <div class="section">
        <h3>Live Stats (this session)</h3>
        <div class="stat-grid">
          <div class="stat">
            <span class="stat-label">Total Bets</span>
            <span class="stat-value" id="liveTotalBets">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Wins</span>
            <span class="stat-value" id="liveWins">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Losses</span>
            <span class="stat-value" id="liveLosses">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Hit Rate</span>
            <span class="stat-value" id="liveHitRate">–</span>
          </div>
          <div class="stat">
            <span class="stat-label">Current Losing Streak</span>
            <span class="stat-value" id="liveCurrentStreak">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Worst Losing Streak</span>
            <span class="stat-value" id="liveWorstStreak">0</span>
          </div>
        </div>
      </div>
    </div>

    <!-- SIMULATOR -->
    <div class="card">
      <h2>Simulator</h2>
      <p class="small">
        Paste a list of spins (one per line or separated by spaces). The simulator will run the same
        hybrid model across that history and show performance stats.
      </p>
      <label for="simInput">Spin sequence</label>
      <textarea id="simInput" placeholder="Example:
26 34 16 4 10 10 27 29 17 8 35 7 23 36 36 25 10 21 8 19 ..."></textarea>

      <div>
        <button class="btn btn-primary" id="runSimBtn">Run Simulation</button>
        <button class="btn btn-secondary" id="clearSimBtn">Clear</button>
      </div>

      <div class="section" id="simResults" style="display:none;">
        <h3>Simulation Results</h3>
        <div class="stat-grid">
          <div class="stat">
            <span class="stat-label">Spins</span>
            <span class="stat-value" id="simSpins">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Total Bets</span>
            <span class="stat-value" id="simTotalBets">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Wins</span>
            <span class="stat-value" id="simWins">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Losses</span>
            <span class="stat-value" id="simLosses">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">Hit Rate</span>
            <span class="stat-value" id="simHitRate">–</span>
          </div>
          <div class="stat">
            <span class="stat-label">Worst Losing Streak</span>
            <span class="stat-value" id="simWorstStreak">0</span>
          </div>
        </div>
        <p class="small" id="simNotes"></p>
      </div>
    </div>
  </div>

  <script>
  // ---------- MODEL CONSTANTS ----------

  const WHEEL_ORDER = [
    0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6,
    27, 13, 36, 11, 30, 8, 23, 10, 5, 24,
    16, 33, 1, 20, 14, 31, 9, 22, 18, 29,
    7, 28, 12, 35, 3, 26
  ];

  const INDEX_OF = {};
  WHEEL_ORDER.forEach((n, i) => { INDEX_OF[n] = i; });

  const HALF_SECTOR = 8;               // neighbours each side
  const MIN_SPINS_FOR_MODEL = 10;      // wait for at least this many spins
  const LAMBDA_GLOBAL = 0.5;           // weight for global step distribution in smoothing

  // ---------- UTILITIES ----------

  function neighboursForCentre(centreNum) {
    const idx = INDEX_OF[centreNum];
    if (idx === undefined) return [];
    const nums = [];
    for (let offset = -HALF_SECTOR; offset <= HALF_SECTOR; offset++) {
      const j = (idx + offset + 37) % 37;
      nums.push(WHEEL_ORDER[j]);
    }
    return nums;
  }

  // Build step transition counts from the whole history
  // rowCounts[fromIdx][step] = how many times we saw that step from that number
  // globalCounts[step] = total across all fromIdx
  function buildStepTransitions(spins) {
    const rowCounts = Array.from({ length: 37 }, () => new Array(37).fill(0));
    const globalCounts = new Array(37).fill(0);

    for (let i = 1; i < spins.length; i++) {
      const prev = spins[i - 1];
      const curr = spins[i];
      const idxPrev = INDEX_OF[prev];
      const idxCurr = INDEX_OF[curr];
      if (idxPrev === undefined || idxCurr === undefined) continue;

      const step = (idxCurr - idxPrev + 37) % 37;
      rowCounts[idxPrev][step]++;
      globalCounts[step]++;
    }

    return { rowCounts, globalCounts };
  }

  function pickBestStep(lastIdx, rowCounts, globalCounts) {
    const row = rowCounts[lastIdx];
    if (!row) return null;

    let bestStep = null;
    let bestScore = -Infinity;

    for (let step = 0; step < 37; step++) {
      const localCount = row[step];
      const globalCount = globalCounts[step];
      const score = localCount + LAMBDA_GLOBAL * globalCount;
      if (score > bestScore) {
        bestScore = score;
        bestStep = step;
      }
    }

    return bestStep;
  }

  // ---------- MARKOV STEP PREDICTION MODEL ----------

  function simplePrediction(spins) {
    if (spins.length < MIN_SPINS_FOR_MODEL) {
      return {
        shouldBet: false,
        reason: `Need at least ${MIN_SPINS_FOR_MODEL} spins to estimate transitions`,
        debug: null
      };
    }

    const lastNum = spins[spins.length - 1];
    const lastIdx = INDEX_OF[lastNum];
    if (lastIdx === undefined) {
      return { shouldBet: false, reason: "Last number not on wheel", debug: null };
    }

    const { rowCounts, globalCounts } = buildStepTransitions(spins);

    const bestStep = pickBestStep(lastIdx, rowCounts, globalCounts);
    if (bestStep === null) {
      return {
        shouldBet: false,
        reason: "No valid step found",
        debug: null
      };
    }

    const centreIdx = (lastIdx + bestStep) % 37;
    const centreNum = WHEEL_ORDER[centreIdx];
    const neighbours = neighboursForCentre(centreNum);

    return {
      shouldBet: true,
      centreNum,
      neighbours,
      dominantStep: bestStep,
      reason: `Markov step model: best step from ${lastNum} is ${bestStep}`
    };
  }

  // ---------- LIVE UI LOGIC ----------

  const spinsLive = [];
  let liveTotalBets = 0;
  let liveWins = 0;
  let liveLosses = 0;
  let liveCurrentLosingStreak = 0;
  let liveWorstLosingStreak = 0;

  const spinInput = document.getElementById("spinInput");
  const addSpinBtn = document.getElementById("addSpinBtn");
  const resetSpinsBtn = document.getElementById("resetSpinsBtn");
  const historyInfo = document.getElementById("historyInfo");
  const historyList = document.getElementById("historyList");
  const recommendationDiv = document.getElementById("recommendation");

  const liveTotalBetsEl = document.getElementById("liveTotalBets");
  const liveWinsEl = document.getElementById("liveWins");
  const liveLossesEl = document.getElementById("liveLosses");
  const liveHitRateEl = document.getElementById("liveHitRate");
  const liveCurrentStreakEl = document.getElementById("liveCurrentStreak");
  const liveWorstStreakEl = document.getElementById("liveWorstStreak");

  let lastPrediction = null; // for scoring wins/losses

  function updateHistoryUI() {
    if (spinsLive.length === 0) {
      historyInfo.textContent = "No spins yet.";
      historyList.innerHTML = "";
      return;
    }
    historyInfo.textContent = `Total spins: ${spinsLive.length} (showing last 20)`;
    const last20 = spinsLive.slice(-20);
    historyList.innerHTML = "";
    last20.forEach(n => {
      const li = document.createElement("li");
      li.textContent = n;
      historyList.appendChild(li);
    });
  }

  function updateStatsUI() {
    liveTotalBetsEl.textContent = liveTotalBets;
    liveWinsEl.textContent = liveWins;
    liveLossesEl.textContent = liveLosses;
    liveCurrentStreakEl.textContent = liveCurrentLosingStreak;
    liveWorstStreakEl.textContent = liveWorstLosingStreak;
    if (liveTotalBets === 0) {
      liveHitRateEl.textContent = "–";
    } else {
      const rate = (liveWins / liveTotalBets) * 100;
      liveHitRateEl.textContent = rate.toFixed(1) + "%";
    }
  }

  function renderRecommendation(pred) {
    recommendationDiv.innerHTML = "";
    if (!pred) {
      const pill = document.createElement("span");
      pill.className = "pill pill-neutral";
      pill.textContent = "No Data";
      recommendationDiv.appendChild(pill);
      const p = document.createElement("p");
      p.className = "small";
      p.textContent = "Enter more spins to get a prediction.";
      recommendationDiv.appendChild(p);
      return;
    }

    if (!pred.shouldBet) {
      const pill = document.createElement("span");
      pill.className = "pill pill-neutral";
      pill.textContent = "NO BET";
      recommendationDiv.appendChild(pill);
      const p = document.createElement("p");
      p.className = "small";
      p.textContent = pred.reason || "Pattern not strong enough yet.";
      recommendationDiv.appendChild(p);
    } else {
      const pill = document.createElement("span");
      pill.className = "pill pill-good";
      pill.textContent = "BET";
      recommendationDiv.appendChild(pill);

      const p1 = document.createElement("p");
      p1.innerHTML = `Centre: <strong>${pred.centreNum}</strong> &mdash; Step: <span class="mono">${pred.dominantStep}</span>`;
      recommendationDiv.appendChild(p1);

      const p2 = document.createElement("p");
      p2.className = "small";
      p2.textContent = "Cover this number and its 8 neighbours each side on the wheel:";
      recommendationDiv.appendChild(p2);

      const ul = document.createElement("ul");
      ul.className = "list-inline mono";
      pred.neighbours.forEach(n => {
        const li = document.createElement("li");
        li.textContent = n;
        ul.appendChild(li);
      });
      recommendationDiv.appendChild(ul);
    }
  }

  function onAddSpin() {
    const v = parseInt(spinInput.value, 10);
    if (isNaN(v) || v < 0 || v > 36) {
      alert("Please enter a valid number between 0 and 36.");
      return;
    }

    // Score previous prediction (if any) NOW that we know the outcome
    if (lastPrediction && lastPrediction.shouldBet) {
      liveTotalBets++;
      const neighbours = lastPrediction.neighbours || [];
      const hit = neighbours.includes(v);
      if (hit) {
        liveWins++;
        liveCurrentLosingStreak = 0;
      } else {
        liveLosses++;
        liveCurrentLosingStreak++;
        if (liveCurrentLosingStreak > liveWorstLosingStreak) {
          liveWorstLosingStreak = liveCurrentLosingStreak;
        }
      }
      updateStatsUI();
    }

    spinsLive.push(v);
    spinInput.value = "";
    updateHistoryUI();

    // Compute new prediction for NEXT spin
    const pred = simplePrediction(spinsLive);
    lastPrediction = pred;
    renderRecommendation(pred);
  }

  function onResetSpins() {
    spinsLive.length = 0;
    lastPrediction = null;
    liveTotalBets = 0;
    liveWins = 0;
    liveLosses = 0;
    liveCurrentLosingStreak = 0;
    liveWorstStreak = 0;
    updateHistoryUI();
    updateStatsUI();
    renderRecommendation(null);
  }

  addSpinBtn.addEventListener("click", onAddSpin);
  resetSpinsBtn.addEventListener("click", onResetSpins);
  spinInput.addEventListener("keyup", (e) => {
    if (e.key === "Enter") onAddSpin();
  });

  // ---------- SIMULATOR LOGIC ----------

  const simInput = document.getElementById("simInput");
  const runSimBtn = document.getElementById("runSimBtn");
  const clearSimBtn = document.getElementById("clearSimBtn");
  const simResults = document.getElementById("simResults");
  const simSpinsEl = document.getElementById("simSpins");
  const simTotalBetsEl = document.getElementById("simTotalBets");
  const simWinsEl = document.getElementById("simWins");
  const simLossesEl = document.getElementById("simLosses");
  const simHitRateEl = document.getElementById("simHitRate");
  const simWorstStreakEl = document.getElementById("simWorstStreak");
  const simNotesEl = document.getElementById("simNotes");

  function parseSpinText(text) {
    const tokens = text.split(/[\s,;]+/).filter(Boolean);
    const arr = [];
    for (const t of tokens) {
      const v = parseInt(t, 10);
      if (!isNaN(v) && v >= 0 && v <= 36) {
        arr.push(v);
      }
    }
    return arr;
  }

  function runSimulation() {
    const spins = parseSpinText(simInput.value);
    if (spins.length < MIN_SPINS_FOR_MODEL + 1) {
      alert(`Please paste at least ${MIN_SPINS_FOR_MODEL + 1} valid spins (0–36).`);
      return;
    }

    let totalBets = 0;
    let wins = 0;
    let losses = 0;
    let currentStreak = 0;
    let worstStreak = 0;

    let history = [];
    let lastPred = null;

    for (let i = 0; i < spins.length; i++) {
      const result = spins[i];

      // settle bet from previous prediction
      if (lastPred && lastPred.shouldBet) {
        totalBets++;
        const hit = (lastPred.neighbours || []).includes(result);
        if (hit) {
          wins++;
          currentStreak = 0;
        } else {
          losses++;
          currentStreak++;
          if (currentStreak > worstStreak) worstStreak = currentStreak;
        }
      }

      history.push(result);
      // compute new prediction for next spin
      lastPred = simplePrediction(history);
    }

    simResults.style.display = "block";
    simSpinsEl.textContent = spins.length;
    simTotalBetsEl.textContent = totalBets;
    simWinsEl.textContent = wins;
    simLossesEl.textContent = losses;
    if (totalBets === 0) {
      simHitRateEl.textContent = "–";
    } else {
      simHitRateEl.textContent = (wins / totalBets * 100).toFixed(1) + "%";
    }
    simWorstStreakEl.textContent = worstStreak;
    simNotesEl.textContent =
      `Markov step model: uses all past transitions P(next step | last number) with global smoothing λ=${LAMBDA_GLOBAL}.`;
  }

  function clearSimulation() {
    simInput.value = "";
    simResults.style.display = "none";
  }

  runSimBtn.addEventListener("click", runSimulation);
  clearSimBtn.addEventListener("click", clearSimulation);

  // initial UI
  updateHistoryUI();
  updateStatsUI();
  renderRecommendation(null);
</script>


</body>
</html>








