<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Roulette Directional Distance Predictor</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #0b1020;
      color: #f5f5f5;
    }
    h1, h2, h3 { margin-top: 0; font-weight: 700; }
    h1 { font-size: 1.8rem; }
    h2 { font-size: 1.3rem; margin-top: 1.5rem; }
    h3 { font-size: 1.1rem; margin-top: 1rem; }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(0, 3fr);
      gap: 1.5rem;
    }
    @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }

    .card {
      background: #151a2c;
      border-radius: 14px;
      padding: 1.1rem 1.25rem;
      box-shadow: 0 14px 40px rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.04);
    }

    label { display: block; margin-bottom: 0.35rem; font-size: 0.9rem; opacity: 0.9; }
    input[type="number"], textarea {
      width: 100%;
      padding: 0.6rem 0.7rem;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: #0b1020;
      color: #f5f5f5;
      font-size: 0.95rem;
      outline: none;
    }
    input[type="number"]:focus, textarea:focus {
      border-color: #58d5ff;
      box-shadow: 0 0 0 1px rgba(88,213,255,0.3);
    }
    textarea { min-height: 120px; resize: vertical; }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.55rem 0.9rem;
      border-radius: 999px;
      border: 0;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      margin-right: 0.5rem;
      margin-top: 0.4rem;
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.15s ease;
    }
    .btn-primary {
      background: #ff3366;
      color: #fff;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.05),0 10px 25px rgba(255,51,102,0.4);
    }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 14px 30px rgba(255,51,102,0.5); }
    .btn-secondary { background: #232b49; color: #f5f5f5; }
    .btn-secondary:hover { background: #2f385c; }
    .btn-disabled { opacity: 0.5; cursor: default; pointer-events: none; }

    .pill {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .pill-good { background: rgba(0,200,140,0.15); color: #4cf3b6; }
    .pill-neutral { background: rgba(130,150,255,0.15); color: #b3bfff; }

    .section {
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid rgba(255,255,255,0.06);
    }

    .list-inline {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem 0.4rem;
      margin: 0.25rem 0;
      padding: 0;
      list-style: none;
      font-size: 0.9rem;
    }
    .list-inline li {
      padding: 0.17rem 0.5rem;
      border-radius: 999px;
      background: rgba(255,255,255,0.05);
    }

    .mono { font-family: "SF Mono", Menlo, Consolas, monospace; font-size: 0.85rem; }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.6rem;
      margin-top: 0.4rem;
    }
    @media (max-width: 600px) { .stat-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    .stat {
      background: rgba(255,255,255,0.03);
      border-radius: 10px;
      padding: 0.5rem 0.6rem;
      font-size: 0.8rem;
    }
    .stat span { display: block; }
    .stat-label { opacity: 0.7; margin-bottom: 0.1rem; }
    .stat-value { font-weight: 700; font-size: 0.95rem; }

    .small { font-size: 0.8rem; opacity: 0.8; }

    .top-control { max-width: 1100px; margin: 0 auto 1rem auto; }
    .top-control-inner {
      background: #151a2c;
      border-radius: 14px;
      padding: 0.9rem 1rem;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
    }
    .top-row { display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: flex-end; }
    .top-row label { margin-bottom: 0.1rem; }
    .inline-input { max-width: 160px; }

    table { width: 100%; border-collapse: collapse; margin-top: 0.5rem; }
    th, td {
      padding: 0.3rem 0.4rem;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      text-align: left;
      font-size: 0.8rem;
    }
    th { font-weight: 600; opacity: 0.9; }
    tfoot td { font-weight: 600; }

    .progress {
      width: 100%;
      background: rgba(255,255,255,0.08);
      border-radius: 999px;
      overflow: hidden;
      height: 10px;
      margin-top: 0.4rem;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background: #ff3366;
      transition: width 0.1s linear;
    }
  </style>
</head>
<body>

  <h1>Roulette Directional Distance Predictor</h1>
  <p class="small">
    Optimiser upgraded to be browser-safe:
    <br />• <strong>Early-abort pruning</strong> (stops evaluating a parameter set once it’s already worse than the current best)
    <br />• <strong>Coarse → refine</strong> search (fast pass, then tight search around the winner)
    <br />This prevents the tab freezing/crashing.
    <br /><br />
    <strong>Rolling 5-day mode:</strong> Days 1–5 forced to <span class="mono">shift=1, a=0.60, b=0.28</span>.
    Day 6 uses best params optimised over days 1–5; Day 7 uses days 2–6; etc.
    After a rolling run, the app also saves <strong>Next Day Params</strong> (best over last 5 valid days in your CSV) for Live Mode.
  </p>

  <div class="top-control">
    <div class="top-control-inner">
      <div class="top-row">
        <div class="inline-input">
          <label for="baseUnitInput">Base stake per number</label>
          <input type="number" id="baseUnitInput" min="0.01" step="0.01" value="1" />
        </div>
        <p class="small">
          Base = starting stake per number for Live/Simulator/CSV runs.
          Martingale doubles after each losing bet, resets after 11 consecutive losses.
        </p>
      </div>
      <p class="small" id="currentParamsText"></p>
      <p class="small" id="savedNextDayParamsText"></p>
    </div>
  </div>

  <div class="container">
    <!-- LIVE INPUT / OUTPUT -->
    <div class="card">
      <h2>Live Mode</h2>

      <label for="spinInput">Enter latest spin (0–36), then click "Add Spin"</label>
      <input type="number" id="spinInput" min="0" max="36" placeholder="e.g. 23" />
      <div>
        <button class="btn btn-primary" id="addSpinBtn">Add Spin</button>
        <button class="btn btn-secondary" id="resetSpinsBtn">Reset History</button>
        <button class="btn btn-secondary" id="exportSpinsBtn">Export Session</button>
      </div>

      <div class="section">
        <h3>Current History</h3>
        <div class="small" id="historyInfo">No spins yet.</div>
        <ul class="list-inline mono" id="historyList"></ul>
      </div>

      <div class="section">
        <h3>Next Spin Recommendation</h3>
        <div id="recommendation">
          <span class="pill pill-neutral">No Data</span>
          <p class="small">Enter some spins or bulk-load history to get started.</p>
        </div>
      </div>

      <div class="section">
        <h3>Live Stats (this session)</h3>
        <div class="stat-grid">
          <div class="stat"><span class="stat-label">Total Bets</span><span class="stat-value" id="liveTotalBets">0</span></div>
          <div class="stat"><span class="stat-label">Wins</span><span class="stat-value" id="liveWins">0</span></div>
          <div class="stat"><span class="stat-label">Losses</span><span class="stat-value" id="liveLosses">0</span></div>
          <div class="stat"><span class="stat-label">Hit Rate</span><span class="stat-value" id="liveHitRate">–</span></div>
          <div class="stat"><span class="stat-label">Current Losing Streak</span><span class="stat-value" id="liveCurrentStreak">0</span></div>
          <div class="stat"><span class="stat-label">Worst Losing Streak</span><span class="stat-value" id="liveWorstStreak">0</span></div>
          <div class="stat"><span class="stat-label">Profit / Loss</span><span class="stat-value" id="liveProfit">+0.00</span></div>
          <div class="stat"><span class="stat-label">Current Stake / Number</span><span class="stat-value" id="liveStakePerNumber">–</span></div>
        </div>
      </div>

      <div class="section">
        <h3>Bulk Load Spins</h3>
        <p class="small">
          Paste up to 500 spins (0–36), separated by spaces/commas/new lines.
          This replaces your current live history and re-scores all bets using the current parameters.
        </p>
        <textarea id="bulkLiveInput" placeholder="Example:
26 34 16 4 10 10 27 29 17 8 35 7 23 ..."></textarea>
        <div><button class="btn btn-primary" id="loadBulkLiveBtn">Load Into Live Model</button></div>
      </div>
    </div>

    <!-- SIMULATOR -->
    <div class="card">
      <h2>Simulator</h2>
      <p class="small">
        Paste a list of spins. The simulator runs the same model + Martingale over that history.
      </p>
      <label for="simInput">Spin sequence</label>
      <textarea id="simInput" placeholder="Example:
26 34 16 4 10 10 27 29 17 8 35 7 23 ..."></textarea>

      <div>
        <button class="btn btn-primary" id="runSimBtn">Run Simulation</button>
        <button class="btn btn-secondary" id="clearSimBtn">Clear</button>
      </div>

      <div class="section" id="simResults" style="display:none;">
        <h3>Simulation Results</h3>
        <div class="stat-grid">
          <div class="stat"><span class="stat-label">Spins</span><span class="stat-value" id="simSpins">0</span></div>
          <div class="stat"><span class="stat-label">Total Bets</span><span class="stat-value" id="simTotalBets">0</span></div>
          <div class="stat"><span class="stat-label">Wins</span><span class="stat-value" id="simWins">0</span></div>
          <div class="stat"><span class="stat-label">Losses</span><span class="stat-value" id="simLosses">0</span></div>
          <div class="stat"><span class="stat-label">Hit Rate</span><span class="stat-value" id="simHitRate">–</span></div>
          <div class="stat"><span class="stat-label">Worst Losing Streak</span><span class="stat-value" id="simWorstStreak">0</span></div>
          <div class="stat"><span class="stat-label">Profit / Loss</span><span class="stat-value" id="simProfit">+0.00</span></div>
        </div>
        <p class="small" id="simNotes"></p>
      </div>

      <!-- DAY-BY-DAY CSV SIMULATION & OPTIMISER -->
      <div class="section">
        <h3>Day-by-Day CSV Simulation & Optimiser</h3>
        <p class="small">
          CSV columns = days. First row headers like <span class="mono">Day 1,Day 2,...</span>.
          Each column contains that day’s spins (0–36).
        </p>

        <input type="file" id="dayCsvInput" accept=".csv" />
        <div style="margin-top:0.4rem;">
          <button class="btn btn-secondary" id="runDayCsvBtn">Run Day-by-Day (no optimisation)</button>
          <button class="btn btn-secondary" id="runRolling5Btn">Run Rolling 5-Day Optimised (Day 6+)</button>
          <button class="btn btn-primary" id="optimiseFromCsvBtn">Optimise Model From CSV (All Days)</button>
        </div>

        <div id="optimizerPanel" class="section" style="margin-top:0.6rem;">
          <p class="small" id="optimizerStatus">Optimizer idle.</p>
          <div class="progress"><div class="progress-bar" id="optimizerProgressBar"></div></div>
        </div>

        <div id="dayCsvResults" style="display:none; margin-top:0.75rem;">
          <h3>Day Breakdown</h3>
          <table class="mono">
            <thead>
              <tr>
                <th>Day</th>
                <th>Spins</th>
                <th>Total Bets</th>
                <th>Wins</th>
                <th>Losses</th>
                <th>Hit %</th>
                <th>Worst Losing Streak</th>
                <th>P&amp;L</th>
                <th>Last Bet</th>
                <th>Last Bet P&amp;L</th>
              </tr>
            </thead>
            <tbody id="dayCsvTbody"></tbody>
            <tfoot>
              <tr>
                <td><strong>TOTAL</strong></td>
                <td id="totalSpinsCell"></td>
                <td id="totalBetsCell"></td>
                <td id="totalWinsCell"></td>
                <td id="totalLossesCell"></td>
                <td id="totalHitRateCell"></td>
                <td id="totalWorstStreakCell"></td>
                <td id="totalProfitCell"></td>
                <td></td>
                <td></td>
              </tr>
            </tfoot>
          </table>
          <div id="dayCsvSummary" class="small" style="margin-top:0.75rem;"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =======================
    // MODEL CONSTANTS
    // =======================

    const WHEEL_ORDER = [
      0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6,
      27, 13, 36, 11, 30, 8, 23, 10, 5, 24,
      16, 33, 1, 20, 14, 31, 9, 22, 18, 29,
      7, 28, 12, 35, 3, 26
    ];
    const INDEX_OF = {};
    WHEEL_ORDER.forEach((n, i) => { INDEX_OF[n] = i; });

    const HALF_SECTOR = 8;              // neighbours each side (17 numbers total)
    const LOSS_RESET_MARTINGALE = 11;   // reset stake after 11 consecutive losing bets

    const LS_PARAMS_KEY = "roulette_saved_next_day_params_v2";

    // Active params (used by Live + Simulator + non-rolling day-by-day)
    let AUTO_PARAMS = { extraShift: 2, aFixed: 0.26, bFixed: 0.60 };

    // Rolling rule
    const ROLLING_WINDOW_DAYS = 5;
    const FIRST_5_PARAMS = { extraShift: 1, aFixed: 0.60, bFixed: 0.28 };

    // Optimiser search space
    const EXTRA_SHIFT_OPTIONS = [0, 1, 2, 3, 4, 5];

    // Coarse-to-fine settings (fast + stable)
    const COARSE_STEP = 0.10;   // first pass
    const FINE_STEP   = 0.02;   // refine pass
    const FINE_RADIUS = 0.10;   // refine around coarse winner

    // =======================
    // UTILITIES
    // =======================

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }
    function roundToStep(x, step) { return Math.round(x / step) * step; }

    function neighboursForCentre(centreNum) {
      const idx = INDEX_OF[centreNum];
      if (idx === undefined) return [];
      const nums = [];
      for (let offset = -HALF_SECTOR; offset <= HALF_SECTOR; offset++) {
        const j = (idx + offset + 37) % 37;
        nums.push(WHEEL_ORDER[j]);
      }
      return nums;
    }

    function directionForIndex(i) { return i % 2 === 0 ? "CW" : "CCW"; }

    function buildDirectionalDistances(spins) {
      const distances = [];
      if (spins.length < 2) return distances;
      for (let i = 1; i < spins.length; i++) {
        const prev = spins[i - 1];
        const curr = spins[i];
        const idxPrev = INDEX_OF[prev];
        const idxCurr = INDEX_OF[curr];
        if (idxPrev === undefined || idxCurr === undefined) continue;

        const dir = directionForIndex(i);
        let dist;
        if (dir === "CW") dist = (idxCurr - idxPrev + 37) % 37;
        else dist = (idxPrev - idxCurr + 37) % 37;

        distances.push({ dir, dist });
      }
      return distances;
    }

    function parseSpinText(text) {
      const tokens = text.split(/[\s,;]+/).filter(Boolean);
      const arr = [];
      for (const t of tokens) {
        const v = parseInt(t, 10);
        if (!isNaN(v) && v >= 0 && v <= 36) arr.push(v);
      }
      return arr;
    }

    function getBaseUnit() {
      const input = document.getElementById("baseUnitInput");
      const v = parseFloat(input.value);
      return (!isNaN(v) && v > 0) ? v : 1;
    }

    function formatMoney(x) {
      const sign = x >= 0 ? "+" : "";
      return sign + x.toFixed(2);
    }

    function saveParamsToLocalStorage(params, meta = {}) {
      try {
        localStorage.setItem(LS_PARAMS_KEY, JSON.stringify({
          params, meta, savedAt: new Date().toISOString()
        }));
      } catch (_) {}
    }

    function loadParamsFromLocalStorage() {
      try {
        const raw = localStorage.getItem(LS_PARAMS_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || !parsed.params) return null;
        const p = parsed.params;
        if (typeof p.extraShift !== "number" || typeof p.aFixed !== "number" || typeof p.bFixed !== "number") return null;
        return parsed;
      } catch (_) { return null; }
    }

    // =======================
    // CS PREDICTION MODEL
    // =======================

    function csPrediction(spins, params = AUTO_PARAMS) {
      if (spins.length < 4) {
        return { shouldBet: false, reason: "Need at least 4 spins for the CS flow model.", debug: null };
      }

      const lastNum = spins[spins.length - 1];
      const idxLast = INDEX_OF[lastNum];
      if (idxLast === undefined) return { shouldBet: false, reason: "Last number not on wheel", debug: null };

      const distances = buildDirectionalDistances(spins);

      const nextIndex = spins.length;
      const upcomingDir = directionForIndex(nextIndex);

      const dirDistances = distances.filter(d => d.dir === upcomingDir).map(d => d.dist);
      if (dirDistances.length < 3) {
        return {
          shouldBet: false,
          reason: `Need at least 3 distances in ${upcomingDir} direction (have ${dirDistances.length})`,
          debug: { upcomingDir, dirDistances }
        };
      }

      const S1 = dirDistances[dirDistances.length - 3];
      const S2 = dirDistances[dirDistances.length - 2];
      const S3 = dirDistances[dirDistances.length - 1];

      const beta  = S3 - S2;
      const gamma = (S3 - S2) - (S2 - S1);

      const a = params.aFixed;
      const b = params.bFixed;

      let S4 = S3 + a * beta + b * gamma;
      S4 = Math.round(S4);
      S4 = ((S4 % 37) + 37) % 37;

      const extraShift = params.extraShift || 0;
      const stepWithBias = (S4 + extraShift) % 37;

      let centreIdx;
      if (upcomingDir === "CW") centreIdx = (idxLast + stepWithBias) % 37;
      else centreIdx = (idxLast - stepWithBias + 74) % 37;

      const centreNum = WHEEL_ORDER[centreIdx];
      const neighbours = neighboursForCentre(centreNum);

      return {
        shouldBet: true,
        centreNum,
        neighbours,
        dominantStep: stepWithBias,
        reason: `CS flow: a=${a.toFixed(2)}, b=${b.toFixed(2)}, extraShift=${extraShift}.`,
        debug: { upcomingDir, S1, S2, S3, beta, gamma, S4, extraShift, stepWithBias, centreIdx, centreNum }
      };
    }

    // =======================
    // LIVE MODE + MARTINGALE
    // =======================

    const spinsLive = [];
    let liveTotalBets = 0, liveWins = 0, liveLosses = 0;
    let liveCurrentLosingStreak = 0, liveWorstStreak = 0;
    let liveProfit = 0, liveStakePerNumber = null, liveMartingaleLossCount = 0;
    let lastPrediction = null;

    const spinInput = document.getElementById("spinInput");
    const addSpinBtn = document.getElementById("addSpinBtn");
    const resetSpinsBtn = document.getElementById("resetSpinsBtn");
    const exportSpinsBtn = document.getElementById("exportSpinsBtn");
    const historyInfo = document.getElementById("historyInfo");
    const historyList = document.getElementById("historyList");
    const recommendationDiv = document.getElementById("recommendation");

    const currentParamsText = document.getElementById("currentParamsText");
    const savedNextDayParamsText = document.getElementById("savedNextDayParamsText");

    const liveTotalBetsEl = document.getElementById("liveTotalBets");
    const liveWinsEl = document.getElementById("liveWins");
    const liveLossesEl = document.getElementById("liveLosses");
    const liveHitRateEl = document.getElementById("liveHitRate");
    const liveCurrentStreakEl = document.getElementById("liveCurrentStreak");
    const liveWorstStreakEl = document.getElementById("liveWorstStreak");
    const liveProfitEl = document.getElementById("liveProfit");
    const liveStakePerNumberEl = document.getElementById("liveStakePerNumber");

    function updateCurrentParamsSummary(extraInfo = "") {
      currentParamsText.textContent =
        `Current model parameters: extraShift=${AUTO_PARAMS.extraShift}, a=${AUTO_PARAMS.aFixed.toFixed(2)}, b=${AUTO_PARAMS.bFixed.toFixed(2)}. ` +
        (extraInfo || "Used by Live + Simulator.");
    }

    function updateSavedParamsLine() {
      const loaded = loadParamsFromLocalStorage();
      if (!loaded) {
        savedNextDayParamsText.textContent =
          "Saved Next Day Params: none yet. Run Rolling 5-day CSV to save params for Live Mode.";
        return;
      }
      const p = loaded.params;
      const meta = loaded.meta || {};
      const note = meta.note ? ` — ${meta.note}` : "";
      savedNextDayParamsText.textContent =
        `Saved Next Day Params: shift=${p.extraShift}, a=${p.aFixed.toFixed(2)}, b=${p.bFixed.toFixed(2)} (saved ${loaded.savedAt})${note}`;
    }

    function updateHistoryUI() {
      if (spinsLive.length === 0) {
        historyInfo.textContent = "No spins yet.";
        historyList.innerHTML = "";
        return;
      }
      historyInfo.textContent = `Total spins: ${spinsLive.length} (showing last 20)`;
      const last20 = spinsLive.slice(-20);
      historyList.innerHTML = "";
      last20.forEach(n => {
        const li = document.createElement("li");
        li.textContent = n;
        historyList.appendChild(li);
      });
    }

    function updateStatsUI() {
      liveTotalBetsEl.textContent = liveTotalBets;
      liveWinsEl.textContent = liveWins;
      liveLossesEl.textContent = liveLosses;
      liveCurrentStreakEl.textContent = liveCurrentLosingStreak;
      liveWorstStreakEl.textContent = liveWorstStreak;
      liveHitRateEl.textContent = liveTotalBets ? ((liveWins / liveTotalBets) * 100).toFixed(1) + "%" : "–";
      liveProfitEl.textContent = formatMoney(liveProfit);
      liveStakePerNumberEl.textContent = (liveStakePerNumber == null) ? "–" : liveStakePerNumber.toFixed(2);
    }

    function renderRecommendation(pred) {
      recommendationDiv.innerHTML = "";

      if (!pred) {
        const pill = document.createElement("span");
        pill.className = "pill pill-neutral";
        pill.textContent = "No Data";
        recommendationDiv.appendChild(pill);
        const p = document.createElement("p");
        p.className = "small";
        p.textContent = "Enter more spins to get a prediction.";
        recommendationDiv.appendChild(p);
        return;
      }

      if (!pred.shouldBet) {
        const pill = document.createElement("span");
        pill.className = "pill pill-neutral";
        pill.textContent = "NO BET";
        recommendationDiv.appendChild(pill);
        const p = document.createElement("p");
        p.className = "small";
        p.textContent = pred.reason || "Pattern not strong enough yet.";
        recommendationDiv.appendChild(p);
        return;
      }

      const pill = document.createElement("span");
      pill.className = "pill pill-good";
      pill.textContent = "BET";
      recommendationDiv.appendChild(pill);

      const p1 = document.createElement("p");
      p1.innerHTML = `Centre: <strong>${pred.centreNum}</strong> — Step: <span class="mono">${pred.dominantStep}</span>`;
      recommendationDiv.appendChild(p1);

      const p2 = document.createElement("p");
      p2.className = "small";
      p2.textContent = "Cover this number and its 8 neighbours each side on the wheel (17 numbers):";
      recommendationDiv.appendChild(p2);

      const ul = document.createElement("ul");
      ul.className = "list-inline mono";
      pred.neighbours.forEach(n => {
        const li = document.createElement("li");
        li.textContent = n;
        ul.appendChild(li);
      });
      recommendationDiv.appendChild(ul);

      if (pred.reason) {
        const p3 = document.createElement("p");
        p3.className = "small";
        p3.textContent = pred.reason;
        recommendationDiv.appendChild(p3);
      }
    }

    function onAddSpin() {
      const v = parseInt(spinInput.value, 10);
      if (isNaN(v) || v < 0 || v > 36) {
        alert("Please enter a valid number between 0 and 36.");
        return;
      }

      const baseUnit = getBaseUnit();

      // settle previous bet
      if (lastPrediction && lastPrediction.shouldBet) {
        liveTotalBets++;

        const neighbours = lastPrediction.neighbours || [];
        const stakePerNumberNow = (liveStakePerNumber == null) ? baseUnit : liveStakePerNumber;
        const totalStake = stakePerNumberNow * neighbours.length;
        const hit = neighbours.includes(v);

        if (hit) {
          const profit = (stakePerNumberNow * 36) - totalStake;
          liveProfit += profit;
          liveWins++;
          liveCurrentLosingStreak = 0;
          liveMartingaleLossCount = 0;
          liveStakePerNumber = baseUnit;
        } else {
          liveProfit -= totalStake;
          liveLosses++;
          liveCurrentLosingStreak++;
          if (liveCurrentLosingStreak > liveWorstStreak) liveWorstStreak = liveCurrentLosingStreak;

          liveMartingaleLossCount++;
          if (liveMartingaleLossCount >= LOSS_RESET_MARTINGALE) {
            liveStakePerNumber = baseUnit;
            liveMartingaleLossCount = 0;
          } else {
            liveStakePerNumber = stakePerNumberNow * 2;
          }
        }

        updateStatsUI();
      }

      spinsLive.push(v);
      spinInput.value = "";
      updateHistoryUI();

      lastPrediction = csPrediction(spinsLive, AUTO_PARAMS);
      renderRecommendation(lastPrediction);
    }

    function onResetSpins() {
      spinsLive.length = 0;
      lastPrediction = null;
      liveTotalBets = liveWins = liveLosses = 0;
      liveCurrentLosingStreak = liveWorstStreak = 0;
      liveProfit = 0;
      liveStakePerNumber = null;
      liveMartingaleLossCount = 0;
      updateHistoryUI();
      updateStatsUI();
      renderRecommendation(null);
    }

    function onExportSpins() {
      if (spinsLive.length === 0) { alert("No spins to export yet."); return; }
      const text = spinsLive.join("\n");
      const blob = new Blob([text], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "roulette_spins_session.txt";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 0);
    }

    addSpinBtn.addEventListener("click", onAddSpin);
    resetSpinsBtn.addEventListener("click", onResetSpins);
    exportSpinsBtn.addEventListener("click", onExportSpins);
    spinInput.addEventListener("keyup", (e) => { if (e.key === "Enter") onAddSpin(); });

    // Bulk load into live
    const bulkLiveInput = document.getElementById("bulkLiveInput");
    const loadBulkLiveBtn = document.getElementById("loadBulkLiveBtn");

    loadBulkLiveBtn.addEventListener("click", () => {
      const spins = parseSpinText(bulkLiveInput.value);
      if (spins.length < 2) { alert("Please paste at least 2 valid spins (0–36)."); return; }

      const baseUnit = getBaseUnit();

      // reset live stats
      spinsLive.length = 0;
      liveTotalBets = liveWins = liveLosses = 0;
      liveCurrentLosingStreak = liveWorstStreak = 0;
      liveProfit = 0;
      liveStakePerNumber = null;
      liveMartingaleLossCount = 0;

      let history = [];
      let lastPredLocal = null;

      for (let i = 0; i < spins.length; i++) {
        const result = spins[i];

        if (lastPredLocal && lastPredLocal.shouldBet) {
          liveTotalBets++;
          const neighbours = lastPredLocal.neighbours || [];
          const stakePerNumberNow = (liveStakePerNumber == null) ? baseUnit : liveStakePerNumber;
          const totalStake = stakePerNumberNow * neighbours.length;

          if (neighbours.includes(result)) {
            liveProfit += (stakePerNumberNow * 36) - totalStake;
            liveWins++;
            liveCurrentLosingStreak = 0;
            liveMartingaleLossCount = 0;
            liveStakePerNumber = baseUnit;
          } else {
            liveProfit -= totalStake;
            liveLosses++;
            liveCurrentLosingStreak++;
            if (liveCurrentLosingStreak > liveWorstStreak) liveWorstStreak = liveCurrentLosingStreak;

            liveMartingaleLossCount++;
            if (liveMartingaleLossCount >= LOSS_RESET_MARTINGALE) {
              liveStakePerNumber = baseUnit;
              liveMartingaleLossCount = 0;
            } else {
              liveStakePerNumber = stakePerNumberNow * 2;
            }
          }
        }

        history.push(result);
        spinsLive.push(result);
        lastPredLocal = csPrediction(history, AUTO_PARAMS);
      }

      lastPrediction = lastPredLocal;

      updateHistoryUI();
      updateStatsUI();
      renderRecommendation(lastPredLocal);

      alert(`Loaded ${spins.length} spins into Live Mode.`);
    });

    // =======================
    // SIMULATOR LOGIC
    // =======================

    function simulateSpinsArrayWithParams(spins, baseUnit, params) {
      if (spins.length < 2) return null;

      let totalBets = 0, wins = 0, losses = 0;
      let currentStreak = 0, worstStreak = 0;

      let simProfit = 0;
      let stakePerNumber = null;
      let martingaleLossCount = 0;

      let lastBetResult = "No Bet";
      let lastBetPnL = 0;

      let history = [];
      let lastPred = null;

      for (let i = 0; i < spins.length; i++) {
        const result = spins[i];

        if (lastPred && lastPred.shouldBet) {
          totalBets++;
          const neighbours = lastPred.neighbours || [];
          const stakeNow = (stakePerNumber == null) ? baseUnit : stakePerNumber;
          const totalStake = stakeNow * neighbours.length;

          if (neighbours.includes(result)) {
            const profit = (stakeNow * 36) - totalStake;
            simProfit += profit;
            wins++;
            currentStreak = 0;
            martingaleLossCount = 0;
            stakePerNumber = baseUnit;
            lastBetResult = "Win";
            lastBetPnL = profit;
          } else {
            const profit = -totalStake;
            simProfit += profit;
            losses++;
            currentStreak++;
            if (currentStreak > worstStreak) worstStreak = currentStreak;

            martingaleLossCount++;
            if (martingaleLossCount >= LOSS_RESET_MARTINGALE) {
              stakePerNumber = baseUnit;
              martingaleLossCount = 0;
            } else {
              stakePerNumber = stakeNow * 2;
            }
            lastBetResult = "Loss";
            lastBetPnL = profit;
          }
        }

        history.push(result);
        lastPred = csPrediction(history, params);
      }

      return {
        spinsCount: spins.length,
        totalBets,
        wins,
        losses,
        hitRate: totalBets ? (wins / totalBets) * 100 : null,
        worstStreak,
        profit: simProfit,
        lastBetResult,
        lastBetPnL
      };
    }

    // =======================
    // OPTIMISER (FAST + PRUNING)
    // =======================

    // CAPPED simulation: EARLY ABORT as soon as worstStreak exceeds capWorstStreak
    function simulateSpinsArrayWithParamsCapped(spins, baseUnit, params, capWorstStreak) {
      if (spins.length < 2) return null;

      let totalBets = 0, wins = 0, losses = 0;
      let currentStreak = 0, worstStreak = 0;

      let simProfit = 0;
      let stakePerNumber = null;
      let martingaleLossCount = 0;

      let history = [];
      let lastPred = null;

      for (let i = 0; i < spins.length; i++) {
        const result = spins[i];

        if (lastPred && lastPred.shouldBet) {
          totalBets++;
          const neighbours = lastPred.neighbours || [];
          const stakeNow = (stakePerNumber == null) ? baseUnit : stakePerNumber;
          const totalStake = stakeNow * neighbours.length;

          if (neighbours.includes(result)) {
            simProfit += (stakeNow * 36) - totalStake;
            wins++;
            currentStreak = 0;
            martingaleLossCount = 0;
            stakePerNumber = baseUnit;
          } else {
            simProfit -= totalStake;
            losses++;
            currentStreak++;
            if (currentStreak > worstStreak) worstStreak = currentStreak;

            if (capWorstStreak != null && worstStreak > capWorstStreak) {
              return { aborted: true, worstStreak };
            }

            martingaleLossCount++;
            if (martingaleLossCount >= LOSS_RESET_MARTINGALE) {
              stakePerNumber = baseUnit;
              martingaleLossCount = 0;
            } else {
              stakePerNumber = stakeNow * 2;
            }
          }
        }

        history.push(result);
        lastPred = csPrediction(history, params);
      }

      return {
        aborted: false,
        totalBets,
        wins,
        losses,
        worstStreak,
        profit: simProfit
      };
    }

    function simulateAllDaysWithParamsCapped(allDaysSpins, baseUnit, params, capWorstStreak) {
      let totalWorstStreak = 0;
      let totalProfit = 0;
      let losingDays = 0;
      let daysSimulated = 0;

      for (const spins of allDaysSpins) {
        if (!spins || spins.length < 2) continue;

        const dayRes = simulateSpinsArrayWithParamsCapped(spins, baseUnit, params, capWorstStreak);

        if (!dayRes) continue;
        if (dayRes.aborted) return { aborted: true };

        daysSimulated++;
        totalProfit += dayRes.profit;
        if (dayRes.profit < 0) losingDays++;
        if (dayRes.worstStreak > totalWorstStreak) totalWorstStreak = dayRes.worstStreak;

        if (capWorstStreak != null && totalWorstStreak > capWorstStreak) {
          return { aborted: true };
        }
      }

      return { aborted: false, totalWorstStreak, totalProfit, losingDays, daysSimulated };
    }

    function isBetterCandidate(res, best) {
      if (!best) return true;
      if (res.totalWorstStreak !== best.totalWorstStreak) return res.totalWorstStreak < best.totalWorstStreak;
      if (res.losingDays !== best.losingDays) return res.losingDays < best.losingDays;
      return res.totalProfit > best.totalProfit;
    }

    function buildGrid(step, centerA = null, centerB = null, radius = null) {
      const grid = [];
      for (const extraShift of EXTRA_SHIFT_OPTIONS) {
        const aMin = (centerA == null) ? 0 : clamp01(centerA - radius);
        const aMax = (centerA == null) ? 1 : clamp01(centerA + radius);
        const bMin = (centerB == null) ? 0 : clamp01(centerB - radius);
        const bMax = (centerB == null) ? 1 : clamp01(centerB + radius);

        let aStart = roundToStep(aMin, step);
        let bStart = roundToStep(bMin, step);

        for (let a = aStart; a <= aMax + 1e-9; a += step) {
          a = parseFloat(a.toFixed(2));
          if (a < 0 || a > 1) continue;
          for (let b = bStart; b <= bMax + 1e-9; b += step) {
            b = parseFloat(b.toFixed(2));
            if (b < 0 || b > 1) continue;
            grid.push({ extraShift, aFixed: a, bFixed: b });
          }
        }
      }
      return grid;
    }

    // Coarse-to-fine optimiser for a set of days (uses pruning)
    // Returns params only: {extraShift, aFixed, bFixed}
    async function optimiseParamsCoarseToFine(allDaysSpins, baseUnit, progressCb) {
      // Pass 1: coarse
      let best = null;
      const coarseGrid = buildGrid(COARSE_STEP, null, null, null);
      for (let i = 0; i < coarseGrid.length; i++) {
        const p = coarseGrid[i];
        const cap = best ? best.totalWorstStreak : null;
        const res = simulateAllDaysWithParamsCapped(allDaysSpins, baseUnit, p, cap);
        if (res && !res.aborted && res.daysSimulated > 0) {
          const candidate = { ...p, ...res };
          if (isBetterCandidate(candidate, best)) best = candidate;
        }

        if (progressCb && (i % 50 === 0)) {
          progressCb({ phase: "coarse", done: i + 1, total: coarseGrid.length, best });
          await new Promise(r => requestAnimationFrame(r));
        }
      }

      if (!best) return { ...FIRST_5_PARAMS };

      // Pass 2: refine around coarse winner
      const refineGrid = buildGrid(FINE_STEP, best.aFixed, best.bFixed, FINE_RADIUS);
      for (let i = 0; i < refineGrid.length; i++) {
        const p = refineGrid[i];
        // keep extraShift fixed to best.extraShift? (much faster)
        if (p.extraShift !== best.extraShift) continue;

        const cap = best ? best.totalWorstStreak : null;
        const res = simulateAllDaysWithParamsCapped(allDaysSpins, baseUnit, p, cap);
        if (res && !res.aborted && res.daysSimulated > 0) {
          const candidate = { ...p, ...res };
          if (isBetterCandidate(candidate, best)) best = candidate;
        }

        if (progressCb && (i % 50 === 0)) {
          progressCb({ phase: "refine", done: i + 1, total: refineGrid.length, best });
          await new Promise(r => requestAnimationFrame(r));
        }
      }

      return { extraShift: best.extraShift, aFixed: best.aFixed, bFixed: best.bFixed };
    }

    // =======================
    // SIMULATOR UI
    // =======================

    const simInput = document.getElementById("simInput");
    const runSimBtn = document.getElementById("runSimBtn");
    const clearSimBtn = document.getElementById("clearSimBtn");
    const simResults = document.getElementById("simResults");
    const simSpinsEl = document.getElementById("simSpins");
    const simTotalBetsEl = document.getElementById("simTotalBets");
    const simWinsEl = document.getElementById("simWins");
    const simLossesEl = document.getElementById("simLosses");
    const simHitRateEl = document.getElementById("simHitRate");
    const simWorstStreakEl = document.getElementById("simWorstStreak");
    const simProfitEl = document.getElementById("simProfit");
    const simNotesEl = document.getElementById("simNotes");

    runSimBtn.addEventListener("click", () => {
      const spins = parseSpinText(simInput.value);
      if (spins.length < 2) { alert("Please paste at least 2 valid spins (0–36)."); return; }
      const baseUnit = getBaseUnit();
      const res = simulateSpinsArrayWithParams(spins, baseUnit, AUTO_PARAMS);
      if (!res) { alert("Not enough spins to simulate."); return; }

      simResults.style.display = "block";
      simSpinsEl.textContent = res.spinsCount;
      simTotalBetsEl.textContent = res.totalBets;
      simWinsEl.textContent = res.wins;
      simLossesEl.textContent = res.losses;
      simHitRateEl.textContent = res.totalBets ? res.hitRate.toFixed(1) + "%" : "–";
      simWorstStreakEl.textContent = res.worstStreak;
      simProfitEl.textContent = formatMoney(res.profit);
      simNotesEl.textContent =
        `Params: shift=${AUTO_PARAMS.extraShift}, a=${AUTO_PARAMS.aFixed.toFixed(2)}, b=${AUTO_PARAMS.bFixed.toFixed(2)}. ` +
        `Martingale doubles, resets after ${LOSS_RESET_MARTINGALE} losses.`;
    });

    clearSimBtn.addEventListener("click", () => {
      simInput.value = "";
      simResults.style.display = "none";
    });

    // =======================
    // CSV SECTION
    // =======================

    const dayCsvInput = document.getElementById("dayCsvInput");
    const runDayCsvBtn = document.getElementById("runDayCsvBtn");
    const runRolling5Btn = document.getElementById("runRolling5Btn");
    const optimiseFromCsvBtn = document.getElementById("optimiseFromCsvBtn");

    const dayCsvResultsDiv = document.getElementById("dayCsvResults");
    const dayCsvTbody = document.getElementById("dayCsvTbody");
    const totalSpinsCell = document.getElementById("totalSpinsCell");
    const totalBetsCell = document.getElementById("totalBetsCell");
    const totalWinsCell = document.getElementById("totalWinsCell");
    const totalLossesCell = document.getElementById("totalLossesCell");
    const totalHitRateCell = document.getElementById("totalHitRateCell");
    const totalWorstStreakCell = document.getElementById("totalWorstStreakCell");
    const totalProfitCell = document.getElementById("totalProfitCell");
    const dayCsvSummary = document.getElementById("dayCsvSummary");

    const optimizerStatus = document.getElementById("optimizerStatus");
    const optimizerProgressBar = document.getElementById("optimizerProgressBar");

    function parseCsv(text) {
      const lines = text.split(/\r?\n/).filter(line => line.trim() !== "");
      return lines.map(line => line.split(/,|\t/));
    }

    function loadCsvFile(callback) {
      const file = dayCsvInput.files && dayCsvInput.files[0];
      if (!file) { alert("Please choose a CSV file first."); return; }
      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target.result;
        const rows = parseCsv(text);
        if (rows.length < 2) { alert("CSV must have a header row and at least one data row."); return; }
        const headers = rows[0].map(h => h.trim());
        const numCols = headers.length;

        const colsSpins = Array.from({ length: numCols }, () => []);
        for (let r = 1; r < rows.length; r++) {
          const row = rows[r];
          for (let c = 0; c < numCols; c++) {
            const cell = (row[c] || "").trim();
            if (!cell) continue;
            const v = parseInt(cell, 10);
            if (!isNaN(v) && v >= 0 && v <= 36) colsSpins[c].push(v);
          }
        }
        callback({ headers, colsSpins });
      };
      reader.readAsText(file);
    }

    // Day-by-day (no optimisation)
    runDayCsvBtn.addEventListener("click", () => {
      loadCsvFile(({ headers, colsSpins }) => {
        dayCsvTbody.innerHTML = "";
        dayCsvSummary.innerHTML = "";

        let totalSpins = 0, totalBets = 0, totalWins = 0, totalLosses = 0, totalProfit = 0, totalWorstStreak = 0;
        const baseUnit = getBaseUnit();
        const dayStats = [];

        colsSpins.forEach((spins, colIdx) => {
          if (!spins || spins.length < 2) return;
          const res = simulateSpinsArrayWithParams(spins, baseUnit, AUTO_PARAMS);
          if (!res) return;

          totalSpins += res.spinsCount;
          totalBets += res.totalBets;
          totalWins += res.wins;
          totalLosses += res.losses;
          totalProfit += res.profit;
          if (res.worstStreak > totalWorstStreak) totalWorstStreak = res.worstStreak;

          const dayName = headers[colIdx] || `Day ${colIdx + 1}`;
          const hitStr = res.totalBets ? res.hitRate.toFixed(1) + "%" : "–";

          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${dayName}</td>
            <td>${res.spinsCount}</td>
            <td>${res.totalBets}</td>
            <td>${res.wins}</td>
            <td>${res.losses}</td>
            <td>${hitStr}</td>
            <td>${res.worstStreak}</td>
            <td>${formatMoney(res.profit)}</td>
            <td>${res.lastBetResult}</td>
            <td>${formatMoney(res.lastBetPnL)}</td>
          `;
          dayCsvTbody.appendChild(tr);

          dayStats.push({ dayName, profit: res.profit });
        });

        totalSpinsCell.textContent = totalSpins;
        totalBetsCell.textContent = totalBets;
        totalWinsCell.textContent = totalWins;
        totalLossesCell.textContent = totalLosses;
        totalHitRateCell.textContent = totalBets ? ((totalWins / totalBets) * 100).toFixed(1) + "%" : "–";
        totalWorstStreakCell.textContent = totalWorstStreak;
        totalProfitCell.textContent = formatMoney(totalProfit);

        dayCsvSummary.textContent = dayStats.length ? "Day-by-day run complete." : "No valid days found in this CSV.";
        dayCsvResultsDiv.style.display = "block";
      });
    });

    // Rolling 5-day optimised (Day 6+), but efficiently:
    // - For each day >= 6, optimise on previous 5 days using coarse-to-fine + pruning
    runRolling5Btn.addEventListener("click", async () => {
      loadCsvFile(async ({ headers, colsSpins }) => {
        dayCsvTbody.innerHTML = "";
        dayCsvSummary.innerHTML = "";
        dayCsvResultsDiv.style.display = "none";

        const baseUnit = getBaseUnit();

        // Disable buttons while running
        runDayCsvBtn.classList.add("btn-disabled");
        runRolling5Btn.classList.add("btn-disabled");
        optimiseFromCsvBtn.classList.add("btn-disabled");

        optimizerProgressBar.style.width = "0%";
        optimizerStatus.textContent = "Rolling optimiser starting...";

        let totalSpins = 0, totalBets = 0, totalWins = 0, totalLosses = 0, totalProfit = 0, totalWorstStreak = 0;
        const dayStats = [];

        // For Next Day Params (last 5 valid days)
        const validDayIndexes = colsSpins
          .map((sp, idx) => ({ sp, idx }))
          .filter(x => x.sp && x.sp.length >= 2)
          .map(x => x.idx);

        const totalDaysToShow = colsSpins.filter(d => d && d.length >= 2).length || 1;
        let daysProcessed = 0;

        // Optional warm-start: start refine around last found (we do that naturally by coarse-to-fine)
        for (let dayIdx = 0; dayIdx < colsSpins.length; dayIdx++) {
          const spins = colsSpins[dayIdx];
          if (!spins || spins.length < 2) continue;

          let paramsForThisDay = null;

          if (dayIdx < ROLLING_WINDOW_DAYS) {
            paramsForThisDay = { ...FIRST_5_PARAMS };
          } else {
            const windowDays = colsSpins.slice(dayIdx - ROLLING_WINDOW_DAYS, dayIdx).filter(d => d && d.length >= 2);
            optimizerStatus.textContent = `Optimising params for ${headers[dayIdx] || `Day ${dayIdx+1}`} using previous 5 days...`;
            paramsForThisDay = await optimiseParamsCoarseToFine(windowDays, baseUnit, (p) => {
              // small rolling progress (not exact combo count, but stable + responsive)
              const fracPhase = (p.phase === "coarse")
                ? (p.done / p.total) * 0.6
                : 0.6 + (p.done / p.total) * 0.4;

              const dayFrac = (daysProcessed / totalDaysToShow);
              const overall = Math.min(99.5, (dayFrac + (1 / totalDaysToShow) * fracPhase) * 100);
              optimizerProgressBar.style.width = overall.toFixed(1) + "%";
              if (p.best) {
                optimizerStatus.textContent =
                  `Rolling optimise: ${headers[dayIdx] || `Day ${dayIdx+1}`} — phase=${p.phase} — best so far: ` +
                  `streak=${p.best.totalWorstStreak}, shift=${p.best.extraShift}, a=${p.best.aFixed.toFixed(2)}, b=${p.best.bFixed.toFixed(2)}, ` +
                  `losingDays=${p.best.losingDays}, P&L=${formatMoney(p.best.totalProfit)}`;
              }
            });
          }

          // simulate this day with chosen params
          const res = simulateSpinsArrayWithParams(spins, baseUnit, paramsForThisDay);
          if (!res) continue;

          totalSpins += res.spinsCount;
          totalBets += res.totalBets;
          totalWins += res.wins;
          totalLosses += res.losses;
          totalProfit += res.profit;
          if (res.worstStreak > totalWorstStreak) totalWorstStreak = res.worstStreak;

          const dayName = headers[dayIdx] || `Day ${dayIdx + 1}`;
          const hitStr = res.totalBets ? res.hitRate.toFixed(1) + "%" : "–";

          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${dayName}</td>
            <td>${res.spinsCount}</td>
            <td>${res.totalBets}</td>
            <td>${res.wins}</td>
            <td>${res.losses}</td>
            <td>${hitStr}</td>
            <td>${res.worstStreak}</td>
            <td>${formatMoney(res.profit)}</td>
            <td>${res.lastBetResult}</td>
            <td>${formatMoney(res.lastBetPnL)}</td>
          `;
          dayCsvTbody.appendChild(tr);

          dayStats.push({ dayName, profit: res.profit });
          daysProcessed++;
          optimizerProgressBar.style.width = Math.min(99.5, (daysProcessed / totalDaysToShow) * 100).toFixed(1) + "%";
          await new Promise(r => requestAnimationFrame(r));
        }

        // Totals
        totalSpinsCell.textContent = totalSpins;
        totalBetsCell.textContent = totalBets;
        totalWinsCell.textContent = totalWins;
        totalLossesCell.textContent = totalLosses;
        totalHitRateCell.textContent = totalBets ? ((totalWins / totalBets) * 100).toFixed(1) + "%" : "–";
        totalWorstStreakCell.textContent = totalWorstStreak;
        totalProfitCell.textContent = formatMoney(totalProfit);

        // Next Day Params: best over last 5 valid days
        let nextDayParams = null;
        if (validDayIndexes.length >= ROLLING_WINDOW_DAYS) {
          const lastFiveIdx = validDayIndexes.slice(-ROLLING_WINDOW_DAYS);
          const lastFiveDays = lastFiveIdx.map(i => colsSpins[i]);

          optimizerStatus.textContent = "Computing Next Day Params from last 5 valid days...";
          optimizerProgressBar.style.width = "99.5%";

          nextDayParams = await optimiseParamsCoarseToFine(lastFiveDays, baseUnit, null);

          AUTO_PARAMS = { ...nextDayParams };
          updateCurrentParamsSummary("Applied Next Day Params (best over last 5 valid CSV days) for Live Mode.");
          saveParamsToLocalStorage(nextDayParams, {
            note: `Based on last 5 valid days: ${lastFiveIdx.map(i => headers[i] || `Day ${i+1}`).join(", ")}`
          });
          updateSavedParamsLine();
        }

        optimizerProgressBar.style.width = "100%";
        optimizerStatus.textContent = nextDayParams
          ? `Rolling complete. Next Day Params saved for Live: shift=${nextDayParams.extraShift}, a=${nextDayParams.aFixed.toFixed(2)}, b=${nextDayParams.bFixed.toFixed(2)}.`
          : "Rolling complete. Not enough valid days to compute Next Day Params.";

        dayCsvSummary.innerHTML =
          `<strong>Rolling run complete.</strong><br>` +
          (nextDayParams
            ? `Next Day Params saved for Live: shift=${nextDayParams.extraShift}, a=${nextDayParams.aFixed.toFixed(2)}, b=${nextDayParams.bFixed.toFixed(2)}.<br>`
            : `Next Day Params not saved (need at least 5 valid days).<br>`);

        dayCsvResultsDiv.style.display = "block";

        // Re-enable
        runDayCsvBtn.classList.remove("btn-disabled");
        runRolling5Btn.classList.remove("btn-disabled");
        optimiseFromCsvBtn.classList.remove("btn-disabled");
      });
    });

    // Optimise from CSV over ALL days (fast + async + progress)
    let optimiserRunning = false;

    optimiseFromCsvBtn.addEventListener("click", () => {
      if (optimiserRunning) { alert("Optimiser is already running."); return; }

      loadCsvFile(async ({ headers, colsSpins }) => {
        const allDaysSpins = colsSpins.filter(d => d && d.length >= 2);
        if (allDaysSpins.length < 1) { alert("No valid days in CSV."); return; }

        optimiserRunning = true;
        runDayCsvBtn.classList.add("btn-disabled");
        runRolling5Btn.classList.add("btn-disabled");
        optimiseFromCsvBtn.classList.add("btn-disabled");

        optimizerProgressBar.style.width = "0%";
        optimizerStatus.textContent = `Optimising over ${allDaysSpins.length} valid days (coarse→refine + pruning)...`;

        const baseUnit = getBaseUnit();

        const params = await optimiseParamsCoarseToFine(allDaysSpins, baseUnit, (p) => {
          const frac = (p.phase === "coarse")
            ? (p.done / p.total) * 60
            : 60 + (p.done / p.total) * 40;
          optimizerProgressBar.style.width = Math.min(99.5, frac).toFixed(1) + "%";
          if (p.best) {
            optimizerStatus.textContent =
              `Optimising (${p.phase}) — best: streak=${p.best.totalWorstStreak}, ` +
              `shift=${p.best.extraShift}, a=${p.best.aFixed.toFixed(2)}, b=${p.best.bFixed.toFixed(2)}, ` +
              `losingDays=${p.best.losingDays}, P&L=${formatMoney(p.best.totalProfit)}`;
          }
        });

        AUTO_PARAMS = { ...params };
        updateCurrentParamsSummary("Optimised over all valid days (coarse→refine + pruning).");

        optimizerProgressBar.style.width = "100%";
        optimizerStatus.textContent =
          `Done. Best params: shift=${params.extraShift}, a=${params.aFixed.toFixed(2)}, b=${params.bFixed.toFixed(2)}. Applied to Live/Simulator.`;

        optimiserRunning = false;
        runDayCsvBtn.classList.remove("btn-disabled");
        runRolling5Btn.classList.remove("btn-disabled");
        optimiseFromCsvBtn.classList.remove("btn-disabled");
      });
    });

    // =======================
    // INITIAL LOAD
    // =======================

    (function init() {
      const loaded = loadParamsFromLocalStorage();
      if (loaded && loaded.params) {
        AUTO_PARAMS = { ...loaded.params };
        updateCurrentParamsSummary("Loaded saved Next Day Params from localStorage for Live Mode.");
      } else {
        updateCurrentParamsSummary("Using defaults. Run CSV rolling/optimise to update.");
      }
      updateSavedParamsLine();

      updateHistoryUI();
      updateStatsUI();
      renderRecommendation(null);
    })();

  </script>
</body>
</html>
