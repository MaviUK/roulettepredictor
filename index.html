<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Roulette Analyst - 19 Number Prediction with Martingale</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 300px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
        }
        button:hover {
            background-color: #2980b9;
        }
        input[type="number"], input[type="text"] {
            padding: 8px;
            margin: 5px 0;
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 8px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .history-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        .history-item {
            background: #e74c3c;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        .history-item.red {
            background: #e74c3c;
        }
        .history-item.black {
            background: #2c3e50;
        }
        .history-item.green {
            background: #27ae60;
        }
        .predictions {
            text-align: center;
            margin: 20px 0;
        }
        .predicted-number {
            font-size: 2em;
            font-weight: bold;
            color: #e74c3c;
            margin: 10px 0;
        }
        .neighbors {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            margin: 10px 0;
        }
        .neighbor {
            padding: 3px 8px;
            background: #3498db;
            color: white;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .wheel-display {
            text-align: center;
            margin: 20px 0;
        }
        .wheel {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: #27ae60;
            margin: 0 auto;
            position: relative;
            border: 5px solid #2c3e50;
        }
        .stats {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        .selected-numbers {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }
        .selected-number {
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9em;
        }
        .win {
            background-color: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
        }
        .loss {
            background-color: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
        }
        .wheel-markers {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
        .wheel-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background: gold;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .direction-stats {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }
        .direction-stat {
            flex: 1;
            padding: 10px;
            background: #ecf0f1;
            border-radius: 5px;
        }
        .travel-pattern {
            margin-top: 10px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 5px;
        }
        .pattern-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        .neighbor-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 5px;
        }
        .neighbor-group-label {
            font-size: 0.8em;
            margin-bottom: 3px;
            color: #7f8c8d;
        }
        .neighbor-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 3px;
            max-width: 200px;
        }
        .martingale-panel {
            background: #fff8e1;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        .martingale-stats {
            margin-top: 10px;
        }
        .profit {
            color: #27ae60;
            font-weight: bold;
        }
        .loss {
            color: #e74c3c;
            font-weight: bold;
        }
        .current-bet {
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <h1>Advanced Roulette Analyst</h1>
    <p>19-Number Prediction with Directional Learning & Martingale System</p>
    
    <div class="container">
        <div class="panel">
            <h2>Data Input</h2>
            
            <h3>Single Spin Entry</h3>
            <div>
                <input type="number" id="spinInput" placeholder="Enter number (0-36)" min="0" max="36">
                <button id="addSpinBtn">Add Spin</button>
            </div>
            
            <h3>Batch Input</h3>
            <textarea id="batchInput" placeholder="Enter numbers separated by commas or spaces (oldest first)"></textarea>
            <button id="batchAddBtn">Add Multiple Spins</button>
            
            <div class="martingale-panel">
                <h3>Martingale Betting System</h3>
                <div>
                    <label for="baseBet">Base Bet per Number:</label>
                    <input type="number" id="baseBet" min="1" value="1" step="0.5">
                </div>
                <div>
                    <label for="bankroll">Starting Bankroll:</label>
                    <input type="number" id="bankroll" min="1" value="100" step="1">
                </div>
                <button id="resetMartingaleBtn">Reset Martingale</button>
                
                <div class="martingale-stats">
                    <div class="stats-row">
                        <span>Current Bet per Number:</span>
                        <span id="currentBet" class="current-bet">1</span>
                    </div>
                    <div class="stats-row">
                        <span>Current Bankroll:</span>
                        <span id="currentBankroll">100</span>
                    </div>
                    <div class="stats-row">
                        <span>Total Profit/Loss:</span>
                        <span id="totalProfitLoss">0</span>
                    </div>
                    <div class="stats-row">
                        <span>Current Streak:</span>
                        <span id="currentStreak">0</span>
                    </div>
                    <div class="stats-row">
                        <span>Longest Losing Streak:</span>
                        <span id="longestStreak">0</span>
                    </div>
                    <div class="stats-row">
                        <span>Total Bets Won:</span>
                        <span id="betsWon">0</span>
                    </div>
                    <div class="stats-row">
                        <span>Total Bets Lost:</span>
                        <span id="betsLost">0</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Analysis</h2>
            <div class="wheel-display">
                <div class="wheel">
                    <div class="wheel-markers" id="wheelMarkers"></div>
                </div>
            </div>
            
            <div class="predictions">
                <h3>Predicted Landing Zone (19 Numbers)</h3>
                <div class="predicted-number" id="predictedNumber">-</div>
                <div class="neighbors">
                    <div class="neighbor-group">
                        <div class="neighbor-group-label">Left 9 (CCW)</div>
                        <div class="neighbor-container" id="leftNeighbors"></div>
                    </div>
                    <div class="neighbor-group">
                        <div class="neighbor-group-label">Right 9 (CW)</div>
                        <div class="neighbor-container" id="rightNeighbors"></div>
                    </div>
                </div>
            </div>

            <div class="stats">
                <h3>Current Selection</h3>
                <div class="selected-numbers" id="selectedNumbers">
                    <div>No active prediction</div>
                </div>
                
                <h3>Performance Tracking</h3>
                <div class="stats-row">
                    <span>Total Spins:</span>
                    <span id="totalSpins">0</span>
                </div>
                
                <div class="direction-stats">
                    <div class="direction-stat">
                        <h4>Clockwise (CW)</h4>
                        <div class="stats-row">
                            <span>Wins:</span>
                            <span id="cwWins">0</span>
                        </div>
                        <div class="stats-row">
                            <span>Win %:</span>
                            <span id="cwWinPct">0%</span>
                        </div>
                        <div class="stats-row">
                            <span>Avg Travel:</span>
                            <span id="cwAvgTravel">0</span>
                        </div>
                    </div>
                    
                    <div class="direction-stat">
                        <h4>Counter-Clockwise (CCW)</h4>
                        <div class="stats-row">
                            <span>Wins:</span>
                            <span id="ccwWins">0</span>
                        </div>
                        <div class="stats-row">
                            <span>Win %:</span>
                            <span id="ccwWinPct">0%</span>
                        </div>
                        <div class="stats-row">
                            <span>Avg Travel:</span>
                            <span id="ccwAvgTravel">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="travel-pattern">
                    <h4>Recent Travel Patterns</h4>
                    <div id="travelPatterns">
                        <div class="pattern-row">
                            <span>Direction</span>
                            <span>From</span>
                            <span>To</span>
                            <span>Pockets</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Spin History</h2>
            <div class="history-controls">
                <button id="clearHistoryBtn">Clear History</button>
                <button id="exportHistoryBtn">Export Data</button>
                <span id="historyCount">0 spins recorded</span>
            </div>
            <div id="historyList" class="history-list"></div>
        </div>
    </div>

    <script>
        // European wheel layout (single zero)
        const wheelLayout = [
            0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26
        ];

        // Enhanced application state
        let spinHistory = [];
        let currentDirection = 'cw'; // cw = clockwise, ccw = counter-clockwise
        let currentPrediction = null;
        let currentSelection = [];
        let stats = {
            total: 0,
            cw: {
                wins: 0,
                total: 0,
                travelDistances: []
            },
            ccw: {
                wins: 0,
                total: 0,
                travelDistances: []
            },
            travelPatterns: []
        };

        // Martingale system state
        let martingale = {
            baseBet: 1,
            currentBet: 1,
            bankroll: 100,
            totalProfitLoss: 0,
            currentStreak: 0,
            longestStreak: 0,
            betsWon: 0,
            betsLost: 0,
            active: false
        };

        // DOM elements
        const spinInput = document.getElementById('spinInput');
        const addSpinBtn = document.getElementById('addSpinBtn');
        const batchInput = document.getElementById('batchInput');
        const batchAddBtn = document.getElementById('batchAddBtn');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        const exportHistoryBtn = document.getElementById('exportHistoryBtn');
        const historyCountSpan = document.getElementById('historyCount');
        const historyListDiv = document.getElementById('historyList');
        const predictedNumberDiv = document.getElementById('predictedNumber');
        const leftNeighborsDiv = document.getElementById('leftNeighbors');
        const rightNeighborsDiv = document.getElementById('rightNeighbors');
        const selectedNumbersDiv = document.getElementById('selectedNumbers');
        const totalSpinsSpan = document.getElementById('totalSpins');
        const cwWinsSpan = document.getElementById('cwWins');
        const cwWinPctSpan = document.getElementById('cwWinPct');
        const cwAvgTravelSpan = document.getElementById('cwAvgTravel');
        const ccwWinsSpan = document.getElementById('ccwWins');
        const ccwWinPctSpan = document.getElementById('ccwWinPct');
        const ccwAvgTravelSpan = document.getElementById('ccwAvgTravel');
        const travelPatternsDiv = document.getElementById('travelPatterns');
        const wheelMarkersDiv = document.getElementById('wheelMarkers');
        
        // Martingale elements
        const baseBetInput = document.getElementById('baseBet');
        const bankrollInput = document.getElementById('bankroll');
        const resetMartingaleBtn = document.getElementById('resetMartingaleBtn');
        const currentBetSpan = document.getElementById('currentBet');
        const currentBankrollSpan = document.getElementById('currentBankroll');
        const totalProfitLossSpan = document.getElementById('totalProfitLoss');
        const currentStreakSpan = document.getElementById('currentStreak');
        const longestStreakSpan = document.getElementById('longestStreak');
        const betsWonSpan = document.getElementById('betsWon');
        const betsLostSpan = document.getElementById('betsLost');

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            updateHistoryDisplay();
            updateStatsDisplay();
            updateMartingaleDisplay();
            
            // Load from localStorage if available
            loadFromLocalStorage();
        });

        // Event listeners
        addSpinBtn.addEventListener('click', addSingleSpin);
        batchAddBtn.addEventListener('click', addBatchSpins);
        clearHistoryBtn.addEventListener('click', clearHistory);
        exportHistoryBtn.addEventListener('click', exportHistory);
        spinInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addSingleSpin();
        });
        
        // Martingale controls
        baseBetInput.addEventListener('change', updateMartingaleSettings);
        bankrollInput.addEventListener('change', updateMartingaleSettings);
        resetMartingaleBtn.addEventListener('click', resetMartingale);

        // Core functions
        function addSingleSpin() {
            const number = parseInt(spinInput.value);
            if (isNaN(number) || number < 0 || number > 36) {
                alert('Please enter a valid number between 0 and 36');
                return;
            }
            
            recordSpin(number);
            spinInput.value = '';
            spinInput.focus();
        }

        function addBatchSpins() {
            const input = batchInput.value.trim();
            if (!input) return;
            
            const numbers = input.split(/[\s,]+/)
                .map(n => parseInt(n))
                .filter(n => !isNaN(n) && n >= 0 && n <= 36);
            
            if (numbers.length === 0) {
                alert('No valid numbers found');
                return;
            }
            
            numbers.forEach(number => {
                recordSpin(number);
            });
            
            batchInput.value = '';
        }

        function recordSpin(number) {
            const color = getColorForNumber(number);
            const direction = currentDirection;
            
            // Calculate travel distance if we have previous spins
            let travelDistance = 0;
            if (spinHistory.length > 0) {
                const lastSpin = spinHistory[spinHistory.length - 1];
                const lastIndex = wheelLayout.indexOf(lastSpin.number);
                const currentIndex = wheelLayout.indexOf(number);
                
                if (lastSpin.direction === 'cw') {
                    travelDistance = (lastIndex - currentIndex + wheelLayout.length) % wheelLayout.length;
                } else {
                    travelDistance = (currentIndex - lastIndex + wheelLayout.length) % wheelLayout.length;
                }
                
                // Record travel pattern
                stats.travelPatterns.unshift({
                    from: lastSpin.number,
                    to: number,
                    direction: lastSpin.direction,
                    distance: travelDistance
                });
                
                if (stats.travelPatterns.length > 5) {
                    stats.travelPatterns.pop();
                }
            }
            
            // Add to history
            spinHistory.push({
                number,
                color,
                direction,
                timestamp: new Date().toISOString()
            });
            
            // Update direction-specific stats
            if (direction === 'cw') {
                stats.cw.total++;
                stats.cw.travelDistances.push(travelDistance);
            } else {
                stats.ccw.total++;
                stats.ccw.travelDistances.push(travelDistance);
            }
            
            // Check if this number was in our current selection
            if (currentSelection.length > 0) {
                updateStats(number);
                updateMartingaleStats(number);
            }
            
            // Alternate direction for next spin
            currentDirection = currentDirection === 'cw' ? 'ccw' : 'cw';
            
            // Generate new prediction
            generatePrediction();
            
            updateHistoryDisplay();
            updateStatsDisplay();
            updateWheelDisplay();
            updateTravelPatternsDisplay();
            updateMartingaleDisplay();
            
            // Save to localStorage
            saveToLocalStorage();
        }

        function updateMartingaleStats(number) {
            const wasWin = currentSelection.includes(number);
            
            // Calculate total bet amount (bet per number * 19 numbers)
            const totalBetAmount = martingale.currentBet * 19;
            
            if (wasWin) {
                // Win - we get 36 units for each winning number (minus the bet)
                const winAmount = 36 * martingale.currentBet - totalBetAmount;
                martingale.bankroll += winAmount;
                martingale.totalProfitLoss += winAmount;
                martingale.currentStreak = 0;
                martingale.currentBet = martingale.baseBet; // Reset to base bet
                martingale.betsWon++;
            } else {
                // Loss - we lose the total bet amount
                martingale.bankroll -= totalBetAmount;
                martingale.totalProfitLoss -= totalBetAmount;
                martingale.currentStreak++;
                martingale.currentBet *= 2; // Double the bet for next time
                martingale.betsLost++;
                
                // Update longest streak if needed
                if (martingale.currentStreak > martingale.longestStreak) {
                    martingale.longestStreak = martingale.currentStreak;
                }
            }
            
            // Check if bankroll is insufficient for next bet
            if (martingale.bankroll < (martingale.currentBet * 19)) {
                alert(`Bankroll insufficient for next bet! Need ${martingale.currentBet * 19} but only have ${martingale.bankroll}. Resetting to base bet.`);
                martingale.currentBet = martingale.baseBet;
                martingale.currentStreak = 0;
            }
        }

        function updateMartingaleSettings() {
            martingale.baseBet = parseFloat(baseBetInput.value) || 1;
            martingale.bankroll = parseFloat(bankrollInput.value) || 100;
            martingale.currentBet = martingale.baseBet;
            updateMartingaleDisplay();
            saveToLocalStorage();
        }

        function resetMartingale() {
            martingale = {
                baseBet: parseFloat(baseBetInput.value) || 1,
                currentBet: parseFloat(baseBetInput.value) || 1,
                bankroll: parseFloat(bankrollInput.value) || 100,
                totalProfitLoss: 0,
                currentStreak: 0,
                longestStreak: 0,
                betsWon: 0,
                betsLost: 0,
                active: false
            };
            updateMartingaleDisplay();
            saveToLocalStorage();
        }

        function updateMartingaleDisplay() {
            currentBetSpan.textContent = martingale.currentBet.toFixed(2);
            currentBankrollSpan.textContent = martingale.bankroll.toFixed(2);
            
            // Style profit/loss
            totalProfitLossSpan.textContent = Math.abs(martingale.totalProfitLoss).toFixed(2);
            if (martingale.totalProfitLoss >= 0) {
                totalProfitLossSpan.className = 'profit';
                totalProfitLossSpan.textContent = '+' + totalProfitLossSpan.textContent;
            } else {
                totalProfitLossSpan.className = 'loss';
                totalProfitLossSpan.textContent = '-' + totalProfitLossSpan.textContent;
            }
            
            currentStreakSpan.textContent = martingale.currentStreak;
            longestStreakSpan.textContent = martingale.longestStreak;
            betsWonSpan.textContent = martingale.betsWon;
            betsLostSpan.textContent = martingale.betsLost;
        }

        function generatePrediction() {
            if (spinHistory.length < 2) {
                resetPrediction();
                return;
            }
            
            const lastSpin = spinHistory[spinHistory.length - 1];
            const lastIndex = wheelLayout.indexOf(lastSpin.number);
            
            // Get relevant stats for the upcoming spin direction
            const directionStats = currentDirection === 'cw' ? stats.cw : stats.ccw;
            
            // Calculate average travel distance for this direction
            let avgTravel = 10; // Default if not enough data
            if (directionStats.travelDistances.length > 0) {
                avgTravel = directionStats.travelDistances.reduce((a, b) => a + b, 0) / 
                            directionStats.travelDistances.length;
                
                // Apply some randomness to simulate real variance
                avgTravel = avgTravel * (0.9 + Math.random() * 0.2);
            }
            
            // Find similar historical patterns
            const similarPatterns = stats.travelPatterns.filter(
                p => p.direction === currentDirection && 
                     p.from === lastSpin.number
            );
            
            // Adjust prediction based on similar patterns
            if (similarPatterns.length > 0) {
                const patternAvg = similarPatterns.reduce(
                    (sum, p) => sum + p.distance, 0
                ) / similarPatterns.length;
                
                // Blend the general average with pattern-specific average
                avgTravel = (avgTravel * 0.7) + (patternAvg * 0.3);
            }
            
            // Predict landing position
            let predictedIndex;
            if (currentDirection === 'cw') {
                predictedIndex = (lastIndex - Math.round(avgTravel) + wheelLayout.length) % wheelLayout.length;
            } else {
                predictedIndex = (lastIndex + Math.round(avgTravel)) % wheelLayout.length;
            }
            
            const mainPrediction = wheelLayout[predictedIndex];
            
            // Get 9 neighbors on each side
            const leftNeighbors = [];
            const rightNeighbors = [];
            
            for (let i = 1; i <= 9; i++) {
                leftNeighbors.push(
                    wheelLayout[(predictedIndex - i + wheelLayout.length) % wheelLayout.length]
                );
                rightNeighbors.push(
                    wheelLayout[(predictedIndex + i) % wheelLayout.length]
                );
            }
            
            // Update current selection (main + 9 left + 9 right = 19 numbers)
            currentPrediction = mainPrediction;
            currentSelection = [mainPrediction, ...leftNeighbors, ...rightNeighbors];
            
            // Update display
            updatePredictionDisplay(mainPrediction, leftNeighbors, rightNeighbors);
        }

        function updatePredictionDisplay(mainNumber, leftNeighbors, rightNeighbors) {
            const mainColor = getColorForNumber(mainNumber);
            
            predictedNumberDiv.textContent = mainNumber;
            predictedNumberDiv.style.color = mainColor === 'red' ? '#e74c3c' : 
                                          mainColor === 'black' ? '#2c3e50' : '#27ae60';
            
            // Update left neighbors (counter-clockwise)
            leftNeighborsDiv.innerHTML = '';
            leftNeighbors.forEach(neighbor => {
                const neighborColor = getColorForNumber(neighbor);
                const neighborElement = document.createElement('div');
                neighborElement.className = 'neighbor';
                neighborElement.textContent = neighbor;
                neighborElement.style.backgroundColor = neighborColor === 'red' ? '#e74c3c' : 
                                                      neighborColor === 'black' ? '#2c3e50' : '#27ae60';
                leftNeighborsDiv.appendChild(neighborElement);
            });
            
            // Update right neighbors (clockwise)
            rightNeighborsDiv.innerHTML = '';
            rightNeighbors.forEach(neighbor => {
                const neighborColor = getColorForNumber(neighbor);
                const neighborElement = document.createElement('div');
                neighborElement.className = 'neighbor';
                neighborElement.textContent = neighbor;
                neighborElement.style.backgroundColor = neighborColor === 'red' ? '#e74c3c' : 
                                                      neighborColor === 'black' ? '#2c3e50' : '#27ae60';
                rightNeighborsDiv.appendChild(neighborElement);
            });
            
            updateSelectedNumbersDisplay();
        }

        function updateSelectedNumbersDisplay() {
            selectedNumbersDiv.innerHTML = '';
            
            // Group numbers by their position relative to prediction
            const leftNumbers = currentSelection.slice(1, 10).reverse(); // Left neighbors (counter-clockwise)
            const mainNumber = currentSelection[0];
            const rightNumbers = currentSelection.slice(10); // Right neighbors (clockwise)
            
            // Display left neighbors
            leftNumbers.forEach(num => {
                addNumberToSelectionDisplay(num, 'left');
            });
            
            // Display main prediction
            addNumberToSelectionDisplay(mainNumber, 'main');
            
            // Display right neighbors
            rightNumbers.forEach(num => {
                addNumberToSelectionDisplay(num, 'right');
            });
        }

        function addNumberToSelectionDisplay(number, position) {
            const numElement = document.createElement('div');
            numElement.className = 'selected-number';
            numElement.textContent = number;
            
            // Color based on position
            if (position === 'main') {
                numElement.style.backgroundColor = getColorForNumber(number) === 'red' ? '#e74c3c' : 
                                                  getColorForNumber(number) === 'black' ? '#2c3e50' : '#27ae60';
                numElement.style.color = 'white';
            }
            
            // Check if this number was in the last spin
            if (spinHistory.length > 0) {
                const lastNumber = spinHistory[spinHistory.length - 1].number;
                if (number === lastNumber) {
                    numElement.classList.add('win');
                } else if (currentSelection.includes(lastNumber)) {
                    numElement.classList.add('loss');
                }
            }
            
            selectedNumbersDiv.appendChild(numElement);
        }

        function updateStats(number) {
            stats.total++;
            
            const wasWin = currentSelection.includes(number);
            const lastSpin = spinHistory[spinHistory.length - 1];
            
            if (wasWin) {
                if (lastSpin.direction === 'cw') {
                    stats.cw.wins++;
                } else {
                    stats.ccw.wins++;
                }
            }
        }

        function updateStatsDisplay() {
            totalSpinsSpan.textContent = stats.total;
            
            // CW stats
            cwWinsSpan.textContent = stats.cw.wins;
            const cwWinPct = stats.cw.total > 0 ? 
                Math.round((stats.cw.wins / stats.cw.total) * 100) : 0;
            cwWinPctSpan.textContent = `${cwWinPct}%`;
            
            const cwAvgTravel = stats.cw.travelDistances.length > 0 ?
                Math.round(stats.cw.travelDistances.reduce((a, b) => a + b, 0) / 
                          stats.cw.travelDistances.length) : 0;
            cwAvgTravelSpan.textContent = `${cwAvgTravel}`;
            
            // CCW stats
            ccwWinsSpan.textContent = stats.ccw.wins;
            const ccwWinPct = stats.ccw.total > 0 ? 
                Math.round((stats.ccw.wins / stats.ccw.total) * 100) : 0;
            ccwWinPctSpan.textContent = `${ccwWinPct}%`;
            
            const ccwAvgTravel = stats.ccw.travelDistances.length > 0 ?
                Math.round(stats.ccw.travelDistances.reduce((a, b) => a + b, 0) / 
                          stats.ccw.travelDistances.length) : 0;
            ccwAvgTravelSpan.textContent = `${ccwAvgTravel}`;
        }

        function updateTravelPatternsDisplay() {
            travelPatternsDiv.innerHTML = `
                <div class="pattern-row">
                    <span>Direction</span>
                    <span>From</span>
                    <span>To</span>
                    <span>Pockets</span>
                </div>
            `;
            
            stats.travelPatterns.slice(0, 5).forEach(pattern => {
                const row = document.createElement('div');
                row.className = 'pattern-row';
                row.innerHTML = `
                    <span>${pattern.direction.toUpperCase()}</span>
                    <span>${pattern.from}</span>
                    <span>${pattern.to}</span>
                    <span>${pattern.distance}</span>
                `;
                travelPatternsDiv.appendChild(row);
            });
        }

        function updateWheelDisplay() {
            wheelMarkersDiv.innerHTML = '';
            
            if (spinHistory.length === 0) return;
            
            // Show last spin
            const lastSpin = spinHistory[spinHistory.length - 1];
            const lastIndex = wheelLayout.indexOf(lastSpin.number);
            const lastAngle = (lastIndex / wheelLayout.length) * 360;
            
            const lastMarker = document.createElement('div');
            lastMarker.className = 'wheel-marker';
            lastMarker.style.backgroundColor = 'red';
            lastMarker.style.top = `${50 + 40 * Math.cos((lastAngle - 90) * Math.PI / 180)}%`;
            lastMarker.style.left = `${50 + 40 * Math.sin((lastAngle - 90) * Math.PI / 180)}%`;
            lastMarker.title = `Last: ${lastSpin.number} (${lastSpin.direction.toUpperCase()})`;
            wheelMarkersDiv.appendChild(lastMarker);
            
            // Show prediction if available
            if (currentPrediction) {
                const predIndex = wheelLayout.indexOf(currentPrediction);
                const predAngle = (predIndex / wheelLayout.length) * 360;
                
                const predMarker = document.createElement('div');
                predMarker.className = 'wheel-marker';
                predMarker.style.backgroundColor = 'gold';
                predMarker.style.top = `${50 + 40 * Math.cos((predAngle - 90) * Math.PI / 180)}%`;
                predMarker.style.left = `${50 + 40 * Math.sin((predAngle - 90) * Math.PI / 180)}%`;
                predMarker.title = `Predicted: ${currentPrediction} (${currentDirection.toUpperCase()})`;
                wheelMarkersDiv.appendChild(predMarker);
                
                // Show neighborhood range (9 pockets each side)
                const leftIndex = (predIndex - 9 + wheelLayout.length) % wheelLayout.length;
                const rightIndex = (predIndex + 9) % wheelLayout.length;
                
                const leftAngle = (leftIndex / wheelLayout.length) * 360;
                const rightAngle = (rightIndex / wheelLayout.length) * 360;
                
                // Draw arc for prediction range
                const rangeArc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                rangeArc.setAttribute('d', describeArc(150, 150, 120, 
                    (leftAngle - 90) * Math.PI / 180, 
                    (rightAngle - 90) * Math.PI / 180));
                rangeArc.setAttribute('stroke', 'rgba(255, 215, 0, 0.5)');
                rangeArc.setAttribute('stroke-width', '20');
                rangeArc.setAttribute('fill', 'none');
                rangeArc.setAttribute('stroke-linecap', 'round');
                wheelMarkersDiv.appendChild(rangeArc);
            }
        }

        function describeArc(x, y, radius, startAngle, endAngle) {
            const start = polarToCartesian(x, y, radius, endAngle);
            const end = polarToCartesian(x, y, radius, startAngle);
            const largeArcFlag = endAngle - startAngle <= Math.PI ? '0' : '1';
            
            return [
                'M', start.x, start.y,
                'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y
            ].join(' ');
        }

        function polarToCartesian(cx, cy, r, angle) {
            return {
                x: cx + r * Math.cos(angle),
                y: cy + r * Math.sin(angle)
            };
        }

        function updateHistoryDisplay() {
            historyListDiv.innerHTML = '';
            spinHistory.forEach((spin, index) => {
                const spinElement = document.createElement('div');
                spinElement.className = `history-item ${spin.color}`;
                spinElement.textContent = spin.number;
                spinElement.title = `Spin ${index + 1}: ${spin.number} ${spin.color} (${spin.direction.toUpperCase()})`;
                historyListDiv.appendChild(spinElement);
            });
            
            historyCountSpan.textContent = `${spinHistory.length} spins recorded`;
        }

        function resetPrediction() {
            currentPrediction = null;
            currentSelection = [];
            
            predictedNumberDiv.textContent = '-';
            leftNeighborsDiv.innerHTML = '';
            rightNeighborsDiv.innerHTML = '';
            
            selectedNumbersDiv.innerHTML = '<div>No active prediction</div>';
        }

        function clearHistory() {
            if (confirm('Are you sure you want to clear all history?')) {
                spinHistory = [];
                currentDirection = 'cw';
                stats = {
                    total: 0,
                    cw: {
                        wins: 0,
                        total: 0,
                        travelDistances: []
                    },
                    ccw: {
                        wins: 0,
                        total: 0,
                        travelDistances: []
                    },
                    travelPatterns: []
                };
                resetPrediction();
                updateHistoryDisplay();
                updateStatsDisplay();
                updateTravelPatternsDisplay();
                wheelMarkersDiv.innerHTML = '';
                saveToLocalStorage();
            }
        }

        function exportHistory() {
            if (spinHistory.length === 0) {
                alert('No history to export');
                return;
            }
            
            const csvContent = "data:text/csv;charset=utf-8," +
                ["Number,Color,Direction,Timestamp"]
                .concat(spinHistory.map(spin => 
                    `${spin.number},${spin.color},${spin.direction},${spin.timestamp}`
                )).join("\n");
            
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "roulette_history.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function getColorForNumber(number) {
            // 0 is green
            if (number === 0) return 'green';
            
            // Red numbers
            const redNumbers = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36];
            return redNumbers.includes(number) ? 'red' : 'black';
        }
        
        function saveToLocalStorage() {
            const data = {
                spinHistory,
                stats,
                martingale,
                currentDirection,
                currentPrediction,
                currentSelection
            };
            localStorage.setItem('rouletteAnalystData', JSON.stringify(data));
        }
        
        function loadFromLocalStorage() {
            const savedData = localStorage.getItem('rouletteAnalystData');
            if (savedData) {
                const data = JSON.parse(savedData);
                spinHistory = data.spinHistory || [];
                stats = data.stats || {
                    total: 0,
                    cw: { wins: 0, total: 0, travelDistances: [] },
                    ccw: { wins: 0, total: 0, travelDistances: [] },
                    travelPatterns: []
                };
                martingale = data.martingale || {
                    baseBet: 1,
                    currentBet: 1,
                    bankroll: 100,
                    totalProfitLoss: 0,
                    currentStreak: 0,
                    longestStreak: 0,
                    betsWon: 0,
                    betsLost: 0,
                    active: false
                };
                currentDirection = data.currentDirection || 'cw';
                currentPrediction = data.currentPrediction || null;
                currentSelection = data.currentSelection || [];
                
                // Update UI
                updateHistoryDisplay();
                updateStatsDisplay();
                updateMartingaleDisplay();
                updateWheelDisplay();
                updateTravelPatternsDisplay();
                
                if (currentPrediction) {
                    const mainNumber = currentPrediction;
                    const mainIndex = wheelLayout.indexOf(mainNumber);
                    const leftNeighbors = [];
                    const rightNeighbors = [];
                    
                    for (let i = 1; i <= 9; i++) {
                        leftNeighbors.push(
                            wheelLayout[(mainIndex - i + wheelLayout.length) % wheelLayout.length]
                        );
                        rightNeighbors.push(
                            wheelLayout[(mainIndex + i) % wheelLayout.length]
                        );
                    }
                    
                    updatePredictionDisplay(mainNumber, leftNeighbors, rightNeighbors);
                }
                
                // Update inputs to match loaded values
                baseBetInput.value = martingale.baseBet;
                bankrollInput.value = martingale.bankroll;
            }
        }
    </script>
</body>
</html>
